/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: codec.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./gogo";
import * as dependency_2 from "./google/protobuf/descriptor";
import * as pb_1 from "google-protobuf";
export namespace fig.tendermint.codec.v1 {
    export enum SignedMsgType {
        SIGNED_MSG_TYPE_UNKNOWN = 0,
        SIGNED_MSG_TYPE_PREVOTE = 1,
        SIGNED_MSG_TYPE_PRECOMMIT = 2,
        SIGNED_MSG_TYPE_PROPOSAL = 32
    }
    export enum BlockIDFlag {
        BLOCK_ID_FLAG_UNKNOWN = 0,
        BLOCK_ID_FLAG_ABSENT = 1,
        BLOCK_ID_FLAG_COMMIT = 2,
        BLOCK_ID_FLAG_NIL = 3
    }
    export class EventList extends pb_1.Message {
        constructor(data?: any[] | {
            new_block?: EventBlock;
            transaction?: EventTx[];
            validator_set_updates?: EventValidatorSetUpdates;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("new_block" in data && data.new_block != undefined) {
                    this.new_block = data.new_block;
                }
                if ("transaction" in data && data.transaction != undefined) {
                    this.transaction = data.transaction;
                }
                if ("validator_set_updates" in data && data.validator_set_updates != undefined) {
                    this.validator_set_updates = data.validator_set_updates;
                }
            }
        }
        get new_block() {
            return pb_1.Message.getWrapperField(this, EventBlock, 1) as EventBlock;
        }
        set new_block(value: EventBlock) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get transaction() {
            return pb_1.Message.getRepeatedWrapperField(this, EventTx, 2) as EventTx[];
        }
        set transaction(value: EventTx[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get validator_set_updates() {
            return pb_1.Message.getWrapperField(this, EventValidatorSetUpdates, 3) as EventValidatorSetUpdates;
        }
        set validator_set_updates(value: EventValidatorSetUpdates) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            new_block?: ReturnType<typeof EventBlock.prototype.toObject>;
            transaction?: ReturnType<typeof EventTx.prototype.toObject>[];
            validator_set_updates?: ReturnType<typeof EventValidatorSetUpdates.prototype.toObject>;
        }) {
            const message = new EventList({});
            if (data.new_block != null) {
                message.new_block = EventBlock.fromObject(data.new_block);
            }
            if (data.transaction != null) {
                message.transaction = data.transaction.map(item => EventTx.fromObject(item));
            }
            if (data.validator_set_updates != null) {
                message.validator_set_updates = EventValidatorSetUpdates.fromObject(data.validator_set_updates);
            }
            return message;
        }
        toObject() {
            const data: {
                new_block?: ReturnType<typeof EventBlock.prototype.toObject>;
                transaction?: ReturnType<typeof EventTx.prototype.toObject>[];
                validator_set_updates?: ReturnType<typeof EventValidatorSetUpdates.prototype.toObject>;
            } = {};
            if (this.new_block != null) {
                data.new_block = this.new_block.toObject();
            }
            if (this.transaction != null) {
                data.transaction = this.transaction.map((item: EventTx) => item.toObject());
            }
            if (this.validator_set_updates != null) {
                data.validator_set_updates = this.validator_set_updates.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.new_block !== undefined)
                writer.writeMessage(1, this.new_block, () => this.new_block.serialize(writer));
            if (this.transaction !== undefined)
                writer.writeRepeatedMessage(2, this.transaction, (item: EventTx) => item.serialize(writer));
            if (this.validator_set_updates !== undefined)
                writer.writeMessage(3, this.validator_set_updates, () => this.validator_set_updates.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.new_block, () => message.new_block = EventBlock.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.transaction, () => pb_1.Message.addToRepeatedWrapperField(message, 2, EventTx.deserialize(reader), EventTx));
                        break;
                    case 3:
                        reader.readMessage(message.validator_set_updates, () => message.validator_set_updates = EventValidatorSetUpdates.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventList {
            return EventList.deserialize(bytes);
        }
    }
    export class EventData extends pb_1.Message {
        constructor(data?: any[] | {
            event?: Event;
            block?: EventBlock;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event" in data && data.event != undefined) {
                    this.event = data.event;
                }
                if ("block" in data && data.block != undefined) {
                    this.block = data.block;
                }
            }
        }
        get event() {
            return pb_1.Message.getWrapperField(this, Event, 1) as Event;
        }
        set event(value: Event) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get block() {
            return pb_1.Message.getWrapperField(this, EventBlock, 2) as EventBlock;
        }
        set block(value: EventBlock) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            event?: ReturnType<typeof Event.prototype.toObject>;
            block?: ReturnType<typeof EventBlock.prototype.toObject>;
        }) {
            const message = new EventData({});
            if (data.event != null) {
                message.event = Event.fromObject(data.event);
            }
            if (data.block != null) {
                message.block = EventBlock.fromObject(data.block);
            }
            return message;
        }
        toObject() {
            const data: {
                event?: ReturnType<typeof Event.prototype.toObject>;
                block?: ReturnType<typeof EventBlock.prototype.toObject>;
            } = {};
            if (this.event != null) {
                data.event = this.event.toObject();
            }
            if (this.block != null) {
                data.block = this.block.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event !== undefined)
                writer.writeMessage(1, this.event, () => this.event.serialize(writer));
            if (this.block !== undefined)
                writer.writeMessage(2, this.block, () => this.block.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.event, () => message.event = Event.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.block, () => message.block = EventBlock.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventData {
            return EventData.deserialize(bytes);
        }
    }
    export class Block extends pb_1.Message {
        constructor(data?: any[] | {
            header?: Header;
            data?: Data;
            evidence?: EvidenceList;
            last_commit?: Commit;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("evidence" in data && data.evidence != undefined) {
                    this.evidence = data.evidence;
                }
                if ("last_commit" in data && data.last_commit != undefined) {
                    this.last_commit = data.last_commit;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, Header, 1) as Header;
        }
        set header(value: Header) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get data() {
            return pb_1.Message.getWrapperField(this, Data, 2) as Data;
        }
        set data(value: Data) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get evidence() {
            return pb_1.Message.getWrapperField(this, EvidenceList, 3) as EvidenceList;
        }
        set evidence(value: EvidenceList) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get last_commit() {
            return pb_1.Message.getWrapperField(this, Commit, 4) as Commit;
        }
        set last_commit(value: Commit) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            header?: ReturnType<typeof Header.prototype.toObject>;
            data?: ReturnType<typeof Data.prototype.toObject>;
            evidence?: ReturnType<typeof EvidenceList.prototype.toObject>;
            last_commit?: ReturnType<typeof Commit.prototype.toObject>;
        }) {
            const message = new Block({});
            if (data.header != null) {
                message.header = Header.fromObject(data.header);
            }
            if (data.data != null) {
                message.data = Data.fromObject(data.data);
            }
            if (data.evidence != null) {
                message.evidence = EvidenceList.fromObject(data.evidence);
            }
            if (data.last_commit != null) {
                message.last_commit = Commit.fromObject(data.last_commit);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof Header.prototype.toObject>;
                data?: ReturnType<typeof Data.prototype.toObject>;
                evidence?: ReturnType<typeof EvidenceList.prototype.toObject>;
                last_commit?: ReturnType<typeof Commit.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            if (this.evidence != null) {
                data.evidence = this.evidence.toObject();
            }
            if (this.last_commit != null) {
                data.last_commit = this.last_commit.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.header !== undefined)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.data !== undefined)
                writer.writeMessage(2, this.data, () => this.data.serialize(writer));
            if (this.evidence !== undefined)
                writer.writeMessage(3, this.evidence, () => this.evidence.serialize(writer));
            if (this.last_commit !== undefined)
                writer.writeMessage(4, this.last_commit, () => this.last_commit.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Block {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Block();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = Header.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.data, () => message.data = Data.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.evidence, () => message.evidence = EvidenceList.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.last_commit, () => message.last_commit = Commit.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Block {
            return Block.deserialize(bytes);
        }
    }
    export class BlockID extends pb_1.Message {
        constructor(data?: any[] | {
            hash?: Uint8Array;
            part_set_header?: PartSetHeader;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("part_set_header" in data && data.part_set_header != undefined) {
                    this.part_set_header = data.part_set_header;
                }
            }
        }
        get hash() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set hash(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get part_set_header() {
            return pb_1.Message.getWrapperField(this, PartSetHeader, 2) as PartSetHeader;
        }
        set part_set_header(value: PartSetHeader) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            hash?: Uint8Array;
            part_set_header?: ReturnType<typeof PartSetHeader.prototype.toObject>;
        }) {
            const message = new BlockID({});
            if (data.hash != null) {
                message.hash = data.hash;
            }
            if (data.part_set_header != null) {
                message.part_set_header = PartSetHeader.fromObject(data.part_set_header);
            }
            return message;
        }
        toObject() {
            const data: {
                hash?: Uint8Array;
                part_set_header?: ReturnType<typeof PartSetHeader.prototype.toObject>;
            } = {};
            if (this.hash != null) {
                data.hash = this.hash;
            }
            if (this.part_set_header != null) {
                data.part_set_header = this.part_set_header.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hash !== undefined)
                writer.writeBytes(1, this.hash);
            if (this.part_set_header !== undefined)
                writer.writeMessage(2, this.part_set_header, () => this.part_set_header.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockID {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BlockID();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hash = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.part_set_header, () => message.part_set_header = PartSetHeader.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BlockID {
            return BlockID.deserialize(bytes);
        }
    }
    export class BlockParams extends pb_1.Message {
        constructor(data?: any[] | {
            max_bytes?: number;
            max_gas?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("max_bytes" in data && data.max_bytes != undefined) {
                    this.max_bytes = data.max_bytes;
                }
                if ("max_gas" in data && data.max_gas != undefined) {
                    this.max_gas = data.max_gas;
                }
            }
        }
        get max_bytes() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set max_bytes(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get max_gas() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set max_gas(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            max_bytes?: number;
            max_gas?: number;
        }) {
            const message = new BlockParams({});
            if (data.max_bytes != null) {
                message.max_bytes = data.max_bytes;
            }
            if (data.max_gas != null) {
                message.max_gas = data.max_gas;
            }
            return message;
        }
        toObject() {
            const data: {
                max_bytes?: number;
                max_gas?: number;
            } = {};
            if (this.max_bytes != null) {
                data.max_bytes = this.max_bytes;
            }
            if (this.max_gas != null) {
                data.max_gas = this.max_gas;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.max_bytes !== undefined)
                writer.writeInt64(1, this.max_bytes);
            if (this.max_gas !== undefined)
                writer.writeInt64(2, this.max_gas);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BlockParams {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BlockParams();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.max_bytes = reader.readInt64();
                        break;
                    case 2:
                        message.max_gas = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BlockParams {
            return BlockParams.deserialize(bytes);
        }
    }
    export class Commit extends pb_1.Message {
        constructor(data?: any[] | {
            height?: number;
            round?: number;
            block_id?: BlockID;
            signatures?: CommitSig[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("round" in data && data.round != undefined) {
                    this.round = data.round;
                }
                if ("block_id" in data && data.block_id != undefined) {
                    this.block_id = data.block_id;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get height() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get round() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set round(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_id() {
            return pb_1.Message.getWrapperField(this, BlockID, 3) as BlockID;
        }
        set block_id(value: BlockID) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get signatures() {
            return pb_1.Message.getRepeatedWrapperField(this, CommitSig, 4) as CommitSig[];
        }
        set signatures(value: CommitSig[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            height?: number;
            round?: number;
            block_id?: ReturnType<typeof BlockID.prototype.toObject>;
            signatures?: ReturnType<typeof CommitSig.prototype.toObject>[];
        }) {
            const message = new Commit({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.round != null) {
                message.round = data.round;
            }
            if (data.block_id != null) {
                message.block_id = BlockID.fromObject(data.block_id);
            }
            if (data.signatures != null) {
                message.signatures = data.signatures.map(item => CommitSig.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                round?: number;
                block_id?: ReturnType<typeof BlockID.prototype.toObject>;
                signatures?: ReturnType<typeof CommitSig.prototype.toObject>[];
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.round != null) {
                data.round = this.round;
            }
            if (this.block_id != null) {
                data.block_id = this.block_id.toObject();
            }
            if (this.signatures != null) {
                data.signatures = this.signatures.map((item: CommitSig) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height !== undefined)
                writer.writeInt64(1, this.height);
            if (this.round !== undefined)
                writer.writeInt32(2, this.round);
            if (this.block_id !== undefined)
                writer.writeMessage(3, this.block_id, () => this.block_id.serialize(writer));
            if (this.signatures !== undefined)
                writer.writeRepeatedMessage(4, this.signatures, (item: CommitSig) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Commit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Commit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readInt64();
                        break;
                    case 2:
                        message.round = reader.readInt32();
                        break;
                    case 3:
                        reader.readMessage(message.block_id, () => message.block_id = BlockID.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.signatures, () => pb_1.Message.addToRepeatedWrapperField(message, 4, CommitSig.deserialize(reader), CommitSig));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Commit {
            return Commit.deserialize(bytes);
        }
    }
    export class CommitSig extends pb_1.Message {
        constructor(data?: any[] | {
            block_id_flag?: BlockIDFlag;
            validator_address?: Uint8Array;
            timestamp?: Timestamp;
            signature?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("block_id_flag" in data && data.block_id_flag != undefined) {
                    this.block_id_flag = data.block_id_flag;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get block_id_flag() {
            return pb_1.Message.getField(this, 1) as BlockIDFlag;
        }
        set block_id_flag(value: BlockIDFlag) {
            pb_1.Message.setField(this, 1, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set validator_address(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, Timestamp, 3) as Timestamp;
        }
        set timestamp(value: Timestamp) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get signature() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            block_id_flag?: BlockIDFlag;
            validator_address?: Uint8Array;
            timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
            signature?: Uint8Array;
        }) {
            const message = new CommitSig({});
            if (data.block_id_flag != null) {
                message.block_id_flag = data.block_id_flag;
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.timestamp != null) {
                message.timestamp = Timestamp.fromObject(data.timestamp);
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                block_id_flag?: BlockIDFlag;
                validator_address?: Uint8Array;
                timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
                signature?: Uint8Array;
            } = {};
            if (this.block_id_flag != null) {
                data.block_id_flag = this.block_id_flag;
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.block_id_flag !== undefined)
                writer.writeEnum(1, this.block_id_flag);
            if (this.validator_address !== undefined)
                writer.writeBytes(2, this.validator_address);
            if (this.timestamp !== undefined)
                writer.writeMessage(3, this.timestamp, () => this.timestamp.serialize(writer));
            if (this.signature !== undefined)
                writer.writeBytes(4, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CommitSig {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CommitSig();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.block_id_flag = reader.readEnum();
                        break;
                    case 2:
                        message.validator_address = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.timestamp, () => message.timestamp = Timestamp.deserialize(reader));
                        break;
                    case 4:
                        message.signature = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CommitSig {
            return CommitSig.deserialize(bytes);
        }
    }
    export class Consensus extends pb_1.Message {
        constructor(data?: any[] | {
            block?: number;
            app?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("block" in data && data.block != undefined) {
                    this.block = data.block;
                }
                if ("app" in data && data.app != undefined) {
                    this.app = data.app;
                }
            }
        }
        get block() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set block(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get app() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set app(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            block?: number;
            app?: number;
        }) {
            const message = new Consensus({});
            if (data.block != null) {
                message.block = data.block;
            }
            if (data.app != null) {
                message.app = data.app;
            }
            return message;
        }
        toObject() {
            const data: {
                block?: number;
                app?: number;
            } = {};
            if (this.block != null) {
                data.block = this.block;
            }
            if (this.app != null) {
                data.app = this.app;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.block !== undefined)
                writer.writeUint64(1, this.block);
            if (this.app !== undefined)
                writer.writeUint64(2, this.app);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Consensus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Consensus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.block = reader.readUint64();
                        break;
                    case 2:
                        message.app = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Consensus {
            return Consensus.deserialize(bytes);
        }
    }
    export class ConsensusParams extends pb_1.Message {
        constructor(data?: any[] | {
            block?: BlockParams;
            evidence?: EvidenceParams;
            validator?: ValidatorParams;
            version?: VersionParams;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("block" in data && data.block != undefined) {
                    this.block = data.block;
                }
                if ("evidence" in data && data.evidence != undefined) {
                    this.evidence = data.evidence;
                }
                if ("validator" in data && data.validator != undefined) {
                    this.validator = data.validator;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
            }
        }
        get block() {
            return pb_1.Message.getWrapperField(this, BlockParams, 1) as BlockParams;
        }
        set block(value: BlockParams) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get evidence() {
            return pb_1.Message.getWrapperField(this, EvidenceParams, 2) as EvidenceParams;
        }
        set evidence(value: EvidenceParams) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get validator() {
            return pb_1.Message.getWrapperField(this, ValidatorParams, 3) as ValidatorParams;
        }
        set validator(value: ValidatorParams) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get version() {
            return pb_1.Message.getWrapperField(this, VersionParams, 4) as VersionParams;
        }
        set version(value: VersionParams) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            block?: ReturnType<typeof BlockParams.prototype.toObject>;
            evidence?: ReturnType<typeof EvidenceParams.prototype.toObject>;
            validator?: ReturnType<typeof ValidatorParams.prototype.toObject>;
            version?: ReturnType<typeof VersionParams.prototype.toObject>;
        }) {
            const message = new ConsensusParams({});
            if (data.block != null) {
                message.block = BlockParams.fromObject(data.block);
            }
            if (data.evidence != null) {
                message.evidence = EvidenceParams.fromObject(data.evidence);
            }
            if (data.validator != null) {
                message.validator = ValidatorParams.fromObject(data.validator);
            }
            if (data.version != null) {
                message.version = VersionParams.fromObject(data.version);
            }
            return message;
        }
        toObject() {
            const data: {
                block?: ReturnType<typeof BlockParams.prototype.toObject>;
                evidence?: ReturnType<typeof EvidenceParams.prototype.toObject>;
                validator?: ReturnType<typeof ValidatorParams.prototype.toObject>;
                version?: ReturnType<typeof VersionParams.prototype.toObject>;
            } = {};
            if (this.block != null) {
                data.block = this.block.toObject();
            }
            if (this.evidence != null) {
                data.evidence = this.evidence.toObject();
            }
            if (this.validator != null) {
                data.validator = this.validator.toObject();
            }
            if (this.version != null) {
                data.version = this.version.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.block !== undefined)
                writer.writeMessage(1, this.block, () => this.block.serialize(writer));
            if (this.evidence !== undefined)
                writer.writeMessage(2, this.evidence, () => this.evidence.serialize(writer));
            if (this.validator !== undefined)
                writer.writeMessage(3, this.validator, () => this.validator.serialize(writer));
            if (this.version !== undefined)
                writer.writeMessage(4, this.version, () => this.version.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConsensusParams {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConsensusParams();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.block, () => message.block = BlockParams.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.evidence, () => message.evidence = EvidenceParams.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.validator, () => message.validator = ValidatorParams.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.version, () => message.version = VersionParams.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConsensusParams {
            return ConsensusParams.deserialize(bytes);
        }
    }
    export class Data extends pb_1.Message {
        constructor(data?: any[] | {
            txs?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("txs" in data && data.txs != undefined) {
                    this.txs = data.txs;
                }
            }
        }
        get txs() {
            return pb_1.Message.getField(this, 1) as Uint8Array[];
        }
        set txs(value: Uint8Array[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            txs?: Uint8Array[];
        }) {
            const message = new Data({});
            if (data.txs != null) {
                message.txs = data.txs;
            }
            return message;
        }
        toObject() {
            const data: {
                txs?: Uint8Array[];
            } = {};
            if (this.txs != null) {
                data.txs = this.txs;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.txs !== undefined)
                writer.writeRepeatedBytes(1, this.txs);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Data {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Data();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Data {
            return Data.deserialize(bytes);
        }
    }
    export class Duration extends pb_1.Message {
        constructor(data?: any[] | {
            seconds?: number;
            nanos?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("seconds" in data && data.seconds != undefined) {
                    this.seconds = data.seconds;
                }
                if ("nanos" in data && data.nanos != undefined) {
                    this.nanos = data.nanos;
                }
            }
        }
        get seconds() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set seconds(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get nanos() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set nanos(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            seconds?: number;
            nanos?: number;
        }) {
            const message = new Duration({});
            if (data.seconds != null) {
                message.seconds = data.seconds;
            }
            if (data.nanos != null) {
                message.nanos = data.nanos;
            }
            return message;
        }
        toObject() {
            const data: {
                seconds?: number;
                nanos?: number;
            } = {};
            if (this.seconds != null) {
                data.seconds = this.seconds;
            }
            if (this.nanos != null) {
                data.nanos = this.nanos;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.seconds !== undefined)
                writer.writeInt64(1, this.seconds);
            if (this.nanos !== undefined)
                writer.writeInt32(2, this.nanos);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Duration {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Duration();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.seconds = reader.readInt64();
                        break;
                    case 2:
                        message.nanos = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Duration {
            return Duration.deserialize(bytes);
        }
    }
    export class DuplicateVoteEvidence extends pb_1.Message {
        constructor(data?: any[] | {
            vote_a?: EventVote;
            vote_b?: EventVote;
            total_voting_power?: number;
            validator_power?: number;
            timestamp?: Timestamp;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("vote_a" in data && data.vote_a != undefined) {
                    this.vote_a = data.vote_a;
                }
                if ("vote_b" in data && data.vote_b != undefined) {
                    this.vote_b = data.vote_b;
                }
                if ("total_voting_power" in data && data.total_voting_power != undefined) {
                    this.total_voting_power = data.total_voting_power;
                }
                if ("validator_power" in data && data.validator_power != undefined) {
                    this.validator_power = data.validator_power;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
            }
        }
        get vote_a() {
            return pb_1.Message.getWrapperField(this, EventVote, 1) as EventVote;
        }
        set vote_a(value: EventVote) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get vote_b() {
            return pb_1.Message.getWrapperField(this, EventVote, 2) as EventVote;
        }
        set vote_b(value: EventVote) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get total_voting_power() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set total_voting_power(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get validator_power() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set validator_power(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, Timestamp, 5) as Timestamp;
        }
        set timestamp(value: Timestamp) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        static fromObject(data: {
            vote_a?: ReturnType<typeof EventVote.prototype.toObject>;
            vote_b?: ReturnType<typeof EventVote.prototype.toObject>;
            total_voting_power?: number;
            validator_power?: number;
            timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
        }) {
            const message = new DuplicateVoteEvidence({});
            if (data.vote_a != null) {
                message.vote_a = EventVote.fromObject(data.vote_a);
            }
            if (data.vote_b != null) {
                message.vote_b = EventVote.fromObject(data.vote_b);
            }
            if (data.total_voting_power != null) {
                message.total_voting_power = data.total_voting_power;
            }
            if (data.validator_power != null) {
                message.validator_power = data.validator_power;
            }
            if (data.timestamp != null) {
                message.timestamp = Timestamp.fromObject(data.timestamp);
            }
            return message;
        }
        toObject() {
            const data: {
                vote_a?: ReturnType<typeof EventVote.prototype.toObject>;
                vote_b?: ReturnType<typeof EventVote.prototype.toObject>;
                total_voting_power?: number;
                validator_power?: number;
                timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
            } = {};
            if (this.vote_a != null) {
                data.vote_a = this.vote_a.toObject();
            }
            if (this.vote_b != null) {
                data.vote_b = this.vote_b.toObject();
            }
            if (this.total_voting_power != null) {
                data.total_voting_power = this.total_voting_power;
            }
            if (this.validator_power != null) {
                data.validator_power = this.validator_power;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.vote_a !== undefined)
                writer.writeMessage(1, this.vote_a, () => this.vote_a.serialize(writer));
            if (this.vote_b !== undefined)
                writer.writeMessage(2, this.vote_b, () => this.vote_b.serialize(writer));
            if (this.total_voting_power !== undefined)
                writer.writeInt64(3, this.total_voting_power);
            if (this.validator_power !== undefined)
                writer.writeInt64(4, this.validator_power);
            if (this.timestamp !== undefined)
                writer.writeMessage(5, this.timestamp, () => this.timestamp.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DuplicateVoteEvidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DuplicateVoteEvidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.vote_a, () => message.vote_a = EventVote.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.vote_b, () => message.vote_b = EventVote.deserialize(reader));
                        break;
                    case 3:
                        message.total_voting_power = reader.readInt64();
                        break;
                    case 4:
                        message.validator_power = reader.readInt64();
                        break;
                    case 5:
                        reader.readMessage(message.timestamp, () => message.timestamp = Timestamp.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DuplicateVoteEvidence {
            return DuplicateVoteEvidence.deserialize(bytes);
        }
    }
    export class Event extends pb_1.Message {
        constructor(data?: any[] | {
            event_type?: string;
            attributes?: EventAttribute[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_type" in data && data.event_type != undefined) {
                    this.event_type = data.event_type;
                }
                if ("attributes" in data && data.attributes != undefined) {
                    this.attributes = data.attributes;
                }
            }
        }
        get event_type() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set event_type(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get attributes() {
            return pb_1.Message.getRepeatedWrapperField(this, EventAttribute, 2) as EventAttribute[];
        }
        set attributes(value: EventAttribute[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            event_type?: string;
            attributes?: ReturnType<typeof EventAttribute.prototype.toObject>[];
        }) {
            const message = new Event({});
            if (data.event_type != null) {
                message.event_type = data.event_type;
            }
            if (data.attributes != null) {
                message.attributes = data.attributes.map(item => EventAttribute.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                event_type?: string;
                attributes?: ReturnType<typeof EventAttribute.prototype.toObject>[];
            } = {};
            if (this.event_type != null) {
                data.event_type = this.event_type;
            }
            if (this.attributes != null) {
                data.attributes = this.attributes.map((item: EventAttribute) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.event_type === "string" && this.event_type.length)
                writer.writeString(1, this.event_type);
            if (this.attributes !== undefined)
                writer.writeRepeatedMessage(2, this.attributes, (item: EventAttribute) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_type = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.attributes, () => pb_1.Message.addToRepeatedWrapperField(message, 2, EventAttribute.deserialize(reader), EventAttribute));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Event {
            return Event.deserialize(bytes);
        }
    }
    export class EventAttribute extends pb_1.Message {
        constructor(data?: any[] | {
            key?: string;
            value?: string;
            index?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
                if ("index" in data && data.index != undefined) {
                    this.index = data.index;
                }
            }
        }
        get key() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set key(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get index() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set index(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            key?: string;
            value?: string;
            index?: boolean;
        }) {
            const message = new EventAttribute({});
            if (data.key != null) {
                message.key = data.key;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            if (data.index != null) {
                message.index = data.index;
            }
            return message;
        }
        toObject() {
            const data: {
                key?: string;
                value?: string;
                index?: boolean;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            if (this.index != null) {
                data.index = this.index;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.key === "string" && this.key.length)
                writer.writeString(1, this.key);
            if (typeof this.value === "string" && this.value.length)
                writer.writeString(2, this.value);
            if (this.index !== undefined)
                writer.writeBool(3, this.index);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventAttribute {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventAttribute();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    case 3:
                        message.index = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventAttribute {
            return EventAttribute.deserialize(bytes);
        }
    }
    export class EventBlock extends pb_1.Message {
        constructor(data?: any[] | {
            block?: Block;
            block_id?: BlockID;
            result_begin_block?: ResponseBeginBlock;
            result_end_block?: ResponseEndBlock;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("block" in data && data.block != undefined) {
                    this.block = data.block;
                }
                if ("block_id" in data && data.block_id != undefined) {
                    this.block_id = data.block_id;
                }
                if ("result_begin_block" in data && data.result_begin_block != undefined) {
                    this.result_begin_block = data.result_begin_block;
                }
                if ("result_end_block" in data && data.result_end_block != undefined) {
                    this.result_end_block = data.result_end_block;
                }
            }
        }
        get block() {
            return pb_1.Message.getWrapperField(this, Block, 1) as Block;
        }
        set block(value: Block) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get block_id() {
            return pb_1.Message.getWrapperField(this, BlockID, 2) as BlockID;
        }
        set block_id(value: BlockID) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get result_begin_block() {
            return pb_1.Message.getWrapperField(this, ResponseBeginBlock, 3) as ResponseBeginBlock;
        }
        set result_begin_block(value: ResponseBeginBlock) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get result_end_block() {
            return pb_1.Message.getWrapperField(this, ResponseEndBlock, 4) as ResponseEndBlock;
        }
        set result_end_block(value: ResponseEndBlock) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            block?: ReturnType<typeof Block.prototype.toObject>;
            block_id?: ReturnType<typeof BlockID.prototype.toObject>;
            result_begin_block?: ReturnType<typeof ResponseBeginBlock.prototype.toObject>;
            result_end_block?: ReturnType<typeof ResponseEndBlock.prototype.toObject>;
        }) {
            const message = new EventBlock({});
            if (data.block != null) {
                message.block = Block.fromObject(data.block);
            }
            if (data.block_id != null) {
                message.block_id = BlockID.fromObject(data.block_id);
            }
            if (data.result_begin_block != null) {
                message.result_begin_block = ResponseBeginBlock.fromObject(data.result_begin_block);
            }
            if (data.result_end_block != null) {
                message.result_end_block = ResponseEndBlock.fromObject(data.result_end_block);
            }
            return message;
        }
        toObject() {
            const data: {
                block?: ReturnType<typeof Block.prototype.toObject>;
                block_id?: ReturnType<typeof BlockID.prototype.toObject>;
                result_begin_block?: ReturnType<typeof ResponseBeginBlock.prototype.toObject>;
                result_end_block?: ReturnType<typeof ResponseEndBlock.prototype.toObject>;
            } = {};
            if (this.block != null) {
                data.block = this.block.toObject();
            }
            if (this.block_id != null) {
                data.block_id = this.block_id.toObject();
            }
            if (this.result_begin_block != null) {
                data.result_begin_block = this.result_begin_block.toObject();
            }
            if (this.result_end_block != null) {
                data.result_end_block = this.result_end_block.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.block !== undefined)
                writer.writeMessage(1, this.block, () => this.block.serialize(writer));
            if (this.block_id !== undefined)
                writer.writeMessage(2, this.block_id, () => this.block_id.serialize(writer));
            if (this.result_begin_block !== undefined)
                writer.writeMessage(3, this.result_begin_block, () => this.result_begin_block.serialize(writer));
            if (this.result_end_block !== undefined)
                writer.writeMessage(4, this.result_end_block, () => this.result_end_block.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.block, () => message.block = Block.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.block_id, () => message.block_id = BlockID.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.result_begin_block, () => message.result_begin_block = ResponseBeginBlock.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.result_end_block, () => message.result_end_block = ResponseEndBlock.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventBlock {
            return EventBlock.deserialize(bytes);
        }
    }
    export class EventTx extends pb_1.Message {
        constructor(data?: any[] | {
            tx_result?: TxResult;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tx_result" in data && data.tx_result != undefined) {
                    this.tx_result = data.tx_result;
                }
            }
        }
        get tx_result() {
            return pb_1.Message.getWrapperField(this, TxResult, 1) as TxResult;
        }
        set tx_result(value: TxResult) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        static fromObject(data: {
            tx_result?: ReturnType<typeof TxResult.prototype.toObject>;
        }) {
            const message = new EventTx({});
            if (data.tx_result != null) {
                message.tx_result = TxResult.fromObject(data.tx_result);
            }
            return message;
        }
        toObject() {
            const data: {
                tx_result?: ReturnType<typeof TxResult.prototype.toObject>;
            } = {};
            if (this.tx_result != null) {
                data.tx_result = this.tx_result.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.tx_result !== undefined)
                writer.writeMessage(1, this.tx_result, () => this.tx_result.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventTx {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventTx();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tx_result, () => message.tx_result = TxResult.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventTx {
            return EventTx.deserialize(bytes);
        }
    }
    export class EventValidatorSetUpdates extends pb_1.Message {
        constructor(data?: any[] | {
            validator_updates?: Validator[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validator_updates" in data && data.validator_updates != undefined) {
                    this.validator_updates = data.validator_updates;
                }
            }
        }
        get validator_updates() {
            return pb_1.Message.getRepeatedWrapperField(this, Validator, 1) as Validator[];
        }
        set validator_updates(value: Validator[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            validator_updates?: ReturnType<typeof Validator.prototype.toObject>[];
        }) {
            const message = new EventValidatorSetUpdates({});
            if (data.validator_updates != null) {
                message.validator_updates = data.validator_updates.map(item => Validator.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                validator_updates?: ReturnType<typeof Validator.prototype.toObject>[];
            } = {};
            if (this.validator_updates != null) {
                data.validator_updates = this.validator_updates.map((item: Validator) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.validator_updates !== undefined)
                writer.writeRepeatedMessage(1, this.validator_updates, (item: Validator) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventValidatorSetUpdates {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventValidatorSetUpdates();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.validator_updates, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Validator.deserialize(reader), Validator));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventValidatorSetUpdates {
            return EventValidatorSetUpdates.deserialize(bytes);
        }
    }
    export class EventVote extends pb_1.Message {
        constructor(data?: any[] | {
            event_vote_type?: SignedMsgType;
            height?: number;
            round?: number;
            block_id?: BlockID;
            timestamp?: Timestamp;
            validator_address?: Uint8Array;
            validator_index?: number;
            signature?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("event_vote_type" in data && data.event_vote_type != undefined) {
                    this.event_vote_type = data.event_vote_type;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("round" in data && data.round != undefined) {
                    this.round = data.round;
                }
                if ("block_id" in data && data.block_id != undefined) {
                    this.block_id = data.block_id;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("validator_index" in data && data.validator_index != undefined) {
                    this.validator_index = data.validator_index;
                }
                if ("signature" in data && data.signature != undefined) {
                    this.signature = data.signature;
                }
            }
        }
        get event_vote_type() {
            return pb_1.Message.getField(this, 1) as SignedMsgType;
        }
        set event_vote_type(value: SignedMsgType) {
            pb_1.Message.setField(this, 1, value);
        }
        get height() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get round() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set round(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get block_id() {
            return pb_1.Message.getWrapperField(this, BlockID, 4) as BlockID;
        }
        set block_id(value: BlockID) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, Timestamp, 5) as Timestamp;
        }
        set timestamp(value: Timestamp) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set validator_address(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get validator_index() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set validator_index(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get signature() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set signature(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            event_vote_type?: SignedMsgType;
            height?: number;
            round?: number;
            block_id?: ReturnType<typeof BlockID.prototype.toObject>;
            timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
            validator_address?: Uint8Array;
            validator_index?: number;
            signature?: Uint8Array;
        }) {
            const message = new EventVote({});
            if (data.event_vote_type != null) {
                message.event_vote_type = data.event_vote_type;
            }
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.round != null) {
                message.round = data.round;
            }
            if (data.block_id != null) {
                message.block_id = BlockID.fromObject(data.block_id);
            }
            if (data.timestamp != null) {
                message.timestamp = Timestamp.fromObject(data.timestamp);
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.validator_index != null) {
                message.validator_index = data.validator_index;
            }
            if (data.signature != null) {
                message.signature = data.signature;
            }
            return message;
        }
        toObject() {
            const data: {
                event_vote_type?: SignedMsgType;
                height?: number;
                round?: number;
                block_id?: ReturnType<typeof BlockID.prototype.toObject>;
                timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
                validator_address?: Uint8Array;
                validator_index?: number;
                signature?: Uint8Array;
            } = {};
            if (this.event_vote_type != null) {
                data.event_vote_type = this.event_vote_type;
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.round != null) {
                data.round = this.round;
            }
            if (this.block_id != null) {
                data.block_id = this.block_id.toObject();
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.validator_index != null) {
                data.validator_index = this.validator_index;
            }
            if (this.signature != null) {
                data.signature = this.signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.event_vote_type !== undefined)
                writer.writeEnum(1, this.event_vote_type);
            if (this.height !== undefined)
                writer.writeUint64(2, this.height);
            if (this.round !== undefined)
                writer.writeInt32(3, this.round);
            if (this.block_id !== undefined)
                writer.writeMessage(4, this.block_id, () => this.block_id.serialize(writer));
            if (this.timestamp !== undefined)
                writer.writeMessage(5, this.timestamp, () => this.timestamp.serialize(writer));
            if (this.validator_address !== undefined)
                writer.writeBytes(6, this.validator_address);
            if (this.validator_index !== undefined)
                writer.writeInt32(7, this.validator_index);
            if (this.signature !== undefined)
                writer.writeBytes(8, this.signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EventVote {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EventVote();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.event_vote_type = reader.readEnum();
                        break;
                    case 2:
                        message.height = reader.readUint64();
                        break;
                    case 3:
                        message.round = reader.readInt32();
                        break;
                    case 4:
                        reader.readMessage(message.block_id, () => message.block_id = BlockID.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.timestamp, () => message.timestamp = Timestamp.deserialize(reader));
                        break;
                    case 6:
                        message.validator_address = reader.readBytes();
                        break;
                    case 7:
                        message.validator_index = reader.readInt32();
                        break;
                    case 8:
                        message.signature = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EventVote {
            return EventVote.deserialize(bytes);
        }
    }
    export class Evidence extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            duplicate_vote_evidence?: DuplicateVoteEvidence;
            light_client_attack_evidence?: never;
        } | {
            duplicate_vote_evidence?: never;
            light_client_attack_evidence?: LightClientAttackEvidence;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("duplicate_vote_evidence" in data && data.duplicate_vote_evidence != undefined) {
                    this.duplicate_vote_evidence = data.duplicate_vote_evidence;
                }
                if ("light_client_attack_evidence" in data && data.light_client_attack_evidence != undefined) {
                    this.light_client_attack_evidence = data.light_client_attack_evidence;
                }
            }
        }
        get duplicate_vote_evidence() {
            return pb_1.Message.getWrapperField(this, DuplicateVoteEvidence, 1) as DuplicateVoteEvidence;
        }
        set duplicate_vote_evidence(value: DuplicateVoteEvidence) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2], value);
        }
        get light_client_attack_evidence() {
            return pb_1.Message.getWrapperField(this, LightClientAttackEvidence, 2) as LightClientAttackEvidence;
        }
        set light_client_attack_evidence(value: LightClientAttackEvidence) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2], value);
        }
        get sum() {
            const cases: {
                [index: number]: "none" | "duplicate_vote_evidence" | "light_client_attack_evidence";
            } = {
                0: "none",
                1: "duplicate_vote_evidence",
                2: "light_client_attack_evidence"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            duplicate_vote_evidence?: ReturnType<typeof DuplicateVoteEvidence.prototype.toObject>;
            light_client_attack_evidence?: ReturnType<typeof LightClientAttackEvidence.prototype.toObject>;
        }) {
            const message = new Evidence({});
            if (data.duplicate_vote_evidence != null) {
                message.duplicate_vote_evidence = DuplicateVoteEvidence.fromObject(data.duplicate_vote_evidence);
            }
            if (data.light_client_attack_evidence != null) {
                message.light_client_attack_evidence = LightClientAttackEvidence.fromObject(data.light_client_attack_evidence);
            }
            return message;
        }
        toObject() {
            const data: {
                duplicate_vote_evidence?: ReturnType<typeof DuplicateVoteEvidence.prototype.toObject>;
                light_client_attack_evidence?: ReturnType<typeof LightClientAttackEvidence.prototype.toObject>;
            } = {};
            if (this.duplicate_vote_evidence != null) {
                data.duplicate_vote_evidence = this.duplicate_vote_evidence.toObject();
            }
            if (this.light_client_attack_evidence != null) {
                data.light_client_attack_evidence = this.light_client_attack_evidence.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.duplicate_vote_evidence !== undefined)
                writer.writeMessage(1, this.duplicate_vote_evidence, () => this.duplicate_vote_evidence.serialize(writer));
            if (this.light_client_attack_evidence !== undefined)
                writer.writeMessage(2, this.light_client_attack_evidence, () => this.light_client_attack_evidence.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Evidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Evidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.duplicate_vote_evidence, () => message.duplicate_vote_evidence = DuplicateVoteEvidence.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.light_client_attack_evidence, () => message.light_client_attack_evidence = LightClientAttackEvidence.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Evidence {
            return Evidence.deserialize(bytes);
        }
    }
    export class EvidenceList extends pb_1.Message {
        constructor(data?: any[] | {
            evidence?: Evidence[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("evidence" in data && data.evidence != undefined) {
                    this.evidence = data.evidence;
                }
            }
        }
        get evidence() {
            return pb_1.Message.getRepeatedWrapperField(this, Evidence, 1) as Evidence[];
        }
        set evidence(value: Evidence[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            evidence?: ReturnType<typeof Evidence.prototype.toObject>[];
        }) {
            const message = new EvidenceList({});
            if (data.evidence != null) {
                message.evidence = data.evidence.map(item => Evidence.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                evidence?: ReturnType<typeof Evidence.prototype.toObject>[];
            } = {};
            if (this.evidence != null) {
                data.evidence = this.evidence.map((item: Evidence) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.evidence !== undefined)
                writer.writeRepeatedMessage(1, this.evidence, (item: Evidence) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EvidenceList {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EvidenceList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.evidence, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Evidence.deserialize(reader), Evidence));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EvidenceList {
            return EvidenceList.deserialize(bytes);
        }
    }
    export class EvidenceParams extends pb_1.Message {
        constructor(data?: any[] | {
            max_age_num_blocks?: number;
            max_age_duration?: Duration;
            max_bytes?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("max_age_num_blocks" in data && data.max_age_num_blocks != undefined) {
                    this.max_age_num_blocks = data.max_age_num_blocks;
                }
                if ("max_age_duration" in data && data.max_age_duration != undefined) {
                    this.max_age_duration = data.max_age_duration;
                }
                if ("max_bytes" in data && data.max_bytes != undefined) {
                    this.max_bytes = data.max_bytes;
                }
            }
        }
        get max_age_num_blocks() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set max_age_num_blocks(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get max_age_duration() {
            return pb_1.Message.getWrapperField(this, Duration, 2) as Duration;
        }
        set max_age_duration(value: Duration) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get max_bytes() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set max_bytes(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            max_age_num_blocks?: number;
            max_age_duration?: ReturnType<typeof Duration.prototype.toObject>;
            max_bytes?: number;
        }) {
            const message = new EvidenceParams({});
            if (data.max_age_num_blocks != null) {
                message.max_age_num_blocks = data.max_age_num_blocks;
            }
            if (data.max_age_duration != null) {
                message.max_age_duration = Duration.fromObject(data.max_age_duration);
            }
            if (data.max_bytes != null) {
                message.max_bytes = data.max_bytes;
            }
            return message;
        }
        toObject() {
            const data: {
                max_age_num_blocks?: number;
                max_age_duration?: ReturnType<typeof Duration.prototype.toObject>;
                max_bytes?: number;
            } = {};
            if (this.max_age_num_blocks != null) {
                data.max_age_num_blocks = this.max_age_num_blocks;
            }
            if (this.max_age_duration != null) {
                data.max_age_duration = this.max_age_duration.toObject();
            }
            if (this.max_bytes != null) {
                data.max_bytes = this.max_bytes;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.max_age_num_blocks !== undefined)
                writer.writeInt64(1, this.max_age_num_blocks);
            if (this.max_age_duration !== undefined)
                writer.writeMessage(2, this.max_age_duration, () => this.max_age_duration.serialize(writer));
            if (this.max_bytes !== undefined)
                writer.writeInt64(3, this.max_bytes);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EvidenceParams {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EvidenceParams();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.max_age_num_blocks = reader.readInt64();
                        break;
                    case 2:
                        reader.readMessage(message.max_age_duration, () => message.max_age_duration = Duration.deserialize(reader));
                        break;
                    case 3:
                        message.max_bytes = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EvidenceParams {
            return EvidenceParams.deserialize(bytes);
        }
    }
    export class Header extends pb_1.Message {
        constructor(data?: any[] | {
            version?: Consensus;
            chain_id?: string;
            height?: number;
            time?: Timestamp;
            last_block_id?: BlockID;
            last_commit_hash?: Uint8Array;
            data_hash?: Uint8Array;
            validators_hash?: Uint8Array;
            next_validators_hash?: Uint8Array;
            consensus_hash?: Uint8Array;
            app_hash?: Uint8Array;
            last_results_hash?: Uint8Array;
            evidence_hash?: Uint8Array;
            proposer_address?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("chain_id" in data && data.chain_id != undefined) {
                    this.chain_id = data.chain_id;
                }
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("last_block_id" in data && data.last_block_id != undefined) {
                    this.last_block_id = data.last_block_id;
                }
                if ("last_commit_hash" in data && data.last_commit_hash != undefined) {
                    this.last_commit_hash = data.last_commit_hash;
                }
                if ("data_hash" in data && data.data_hash != undefined) {
                    this.data_hash = data.data_hash;
                }
                if ("validators_hash" in data && data.validators_hash != undefined) {
                    this.validators_hash = data.validators_hash;
                }
                if ("next_validators_hash" in data && data.next_validators_hash != undefined) {
                    this.next_validators_hash = data.next_validators_hash;
                }
                if ("consensus_hash" in data && data.consensus_hash != undefined) {
                    this.consensus_hash = data.consensus_hash;
                }
                if ("app_hash" in data && data.app_hash != undefined) {
                    this.app_hash = data.app_hash;
                }
                if ("last_results_hash" in data && data.last_results_hash != undefined) {
                    this.last_results_hash = data.last_results_hash;
                }
                if ("evidence_hash" in data && data.evidence_hash != undefined) {
                    this.evidence_hash = data.evidence_hash;
                }
                if ("proposer_address" in data && data.proposer_address != undefined) {
                    this.proposer_address = data.proposer_address;
                }
            }
        }
        get version() {
            return pb_1.Message.getWrapperField(this, Consensus, 1) as Consensus;
        }
        set version(value: Consensus) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get chain_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set chain_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get height() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get time() {
            return pb_1.Message.getWrapperField(this, Timestamp, 4) as Timestamp;
        }
        set time(value: Timestamp) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get last_block_id() {
            return pb_1.Message.getWrapperField(this, BlockID, 5) as BlockID;
        }
        set last_block_id(value: BlockID) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get last_commit_hash() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set last_commit_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get data_hash() {
            return pb_1.Message.getField(this, 7) as Uint8Array;
        }
        set data_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get validators_hash() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set validators_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get next_validators_hash() {
            return pb_1.Message.getField(this, 9) as Uint8Array;
        }
        set next_validators_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 9, value);
        }
        get consensus_hash() {
            return pb_1.Message.getField(this, 10) as Uint8Array;
        }
        set consensus_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 10, value);
        }
        get app_hash() {
            return pb_1.Message.getField(this, 11) as Uint8Array;
        }
        set app_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 11, value);
        }
        get last_results_hash() {
            return pb_1.Message.getField(this, 12) as Uint8Array;
        }
        set last_results_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 12, value);
        }
        get evidence_hash() {
            return pb_1.Message.getField(this, 13) as Uint8Array;
        }
        set evidence_hash(value: Uint8Array) {
            pb_1.Message.setField(this, 13, value);
        }
        get proposer_address() {
            return pb_1.Message.getField(this, 14) as Uint8Array;
        }
        set proposer_address(value: Uint8Array) {
            pb_1.Message.setField(this, 14, value);
        }
        static fromObject(data: {
            version?: ReturnType<typeof Consensus.prototype.toObject>;
            chain_id?: string;
            height?: number;
            time?: ReturnType<typeof Timestamp.prototype.toObject>;
            last_block_id?: ReturnType<typeof BlockID.prototype.toObject>;
            last_commit_hash?: Uint8Array;
            data_hash?: Uint8Array;
            validators_hash?: Uint8Array;
            next_validators_hash?: Uint8Array;
            consensus_hash?: Uint8Array;
            app_hash?: Uint8Array;
            last_results_hash?: Uint8Array;
            evidence_hash?: Uint8Array;
            proposer_address?: Uint8Array;
        }) {
            const message = new Header({});
            if (data.version != null) {
                message.version = Consensus.fromObject(data.version);
            }
            if (data.chain_id != null) {
                message.chain_id = data.chain_id;
            }
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.time != null) {
                message.time = Timestamp.fromObject(data.time);
            }
            if (data.last_block_id != null) {
                message.last_block_id = BlockID.fromObject(data.last_block_id);
            }
            if (data.last_commit_hash != null) {
                message.last_commit_hash = data.last_commit_hash;
            }
            if (data.data_hash != null) {
                message.data_hash = data.data_hash;
            }
            if (data.validators_hash != null) {
                message.validators_hash = data.validators_hash;
            }
            if (data.next_validators_hash != null) {
                message.next_validators_hash = data.next_validators_hash;
            }
            if (data.consensus_hash != null) {
                message.consensus_hash = data.consensus_hash;
            }
            if (data.app_hash != null) {
                message.app_hash = data.app_hash;
            }
            if (data.last_results_hash != null) {
                message.last_results_hash = data.last_results_hash;
            }
            if (data.evidence_hash != null) {
                message.evidence_hash = data.evidence_hash;
            }
            if (data.proposer_address != null) {
                message.proposer_address = data.proposer_address;
            }
            return message;
        }
        toObject() {
            const data: {
                version?: ReturnType<typeof Consensus.prototype.toObject>;
                chain_id?: string;
                height?: number;
                time?: ReturnType<typeof Timestamp.prototype.toObject>;
                last_block_id?: ReturnType<typeof BlockID.prototype.toObject>;
                last_commit_hash?: Uint8Array;
                data_hash?: Uint8Array;
                validators_hash?: Uint8Array;
                next_validators_hash?: Uint8Array;
                consensus_hash?: Uint8Array;
                app_hash?: Uint8Array;
                last_results_hash?: Uint8Array;
                evidence_hash?: Uint8Array;
                proposer_address?: Uint8Array;
            } = {};
            if (this.version != null) {
                data.version = this.version.toObject();
            }
            if (this.chain_id != null) {
                data.chain_id = this.chain_id;
            }
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.time != null) {
                data.time = this.time.toObject();
            }
            if (this.last_block_id != null) {
                data.last_block_id = this.last_block_id.toObject();
            }
            if (this.last_commit_hash != null) {
                data.last_commit_hash = this.last_commit_hash;
            }
            if (this.data_hash != null) {
                data.data_hash = this.data_hash;
            }
            if (this.validators_hash != null) {
                data.validators_hash = this.validators_hash;
            }
            if (this.next_validators_hash != null) {
                data.next_validators_hash = this.next_validators_hash;
            }
            if (this.consensus_hash != null) {
                data.consensus_hash = this.consensus_hash;
            }
            if (this.app_hash != null) {
                data.app_hash = this.app_hash;
            }
            if (this.last_results_hash != null) {
                data.last_results_hash = this.last_results_hash;
            }
            if (this.evidence_hash != null) {
                data.evidence_hash = this.evidence_hash;
            }
            if (this.proposer_address != null) {
                data.proposer_address = this.proposer_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.version !== undefined)
                writer.writeMessage(1, this.version, () => this.version.serialize(writer));
            if (typeof this.chain_id === "string" && this.chain_id.length)
                writer.writeString(2, this.chain_id);
            if (this.height !== undefined)
                writer.writeUint64(3, this.height);
            if (this.time !== undefined)
                writer.writeMessage(4, this.time, () => this.time.serialize(writer));
            if (this.last_block_id !== undefined)
                writer.writeMessage(5, this.last_block_id, () => this.last_block_id.serialize(writer));
            if (this.last_commit_hash !== undefined)
                writer.writeBytes(6, this.last_commit_hash);
            if (this.data_hash !== undefined)
                writer.writeBytes(7, this.data_hash);
            if (this.validators_hash !== undefined)
                writer.writeBytes(8, this.validators_hash);
            if (this.next_validators_hash !== undefined)
                writer.writeBytes(9, this.next_validators_hash);
            if (this.consensus_hash !== undefined)
                writer.writeBytes(10, this.consensus_hash);
            if (this.app_hash !== undefined)
                writer.writeBytes(11, this.app_hash);
            if (this.last_results_hash !== undefined)
                writer.writeBytes(12, this.last_results_hash);
            if (this.evidence_hash !== undefined)
                writer.writeBytes(13, this.evidence_hash);
            if (this.proposer_address !== undefined)
                writer.writeBytes(14, this.proposer_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Header {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Header();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.version, () => message.version = Consensus.deserialize(reader));
                        break;
                    case 2:
                        message.chain_id = reader.readString();
                        break;
                    case 3:
                        message.height = reader.readUint64();
                        break;
                    case 4:
                        reader.readMessage(message.time, () => message.time = Timestamp.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.last_block_id, () => message.last_block_id = BlockID.deserialize(reader));
                        break;
                    case 6:
                        message.last_commit_hash = reader.readBytes();
                        break;
                    case 7:
                        message.data_hash = reader.readBytes();
                        break;
                    case 8:
                        message.validators_hash = reader.readBytes();
                        break;
                    case 9:
                        message.next_validators_hash = reader.readBytes();
                        break;
                    case 10:
                        message.consensus_hash = reader.readBytes();
                        break;
                    case 11:
                        message.app_hash = reader.readBytes();
                        break;
                    case 12:
                        message.last_results_hash = reader.readBytes();
                        break;
                    case 13:
                        message.evidence_hash = reader.readBytes();
                        break;
                    case 14:
                        message.proposer_address = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Header {
            return Header.deserialize(bytes);
        }
    }
    export class LightBlock extends pb_1.Message {
        constructor(data?: any[] | {
            signed_header?: SignedHeader;
            validator_set?: ValidatorSet;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signed_header" in data && data.signed_header != undefined) {
                    this.signed_header = data.signed_header;
                }
                if ("validator_set" in data && data.validator_set != undefined) {
                    this.validator_set = data.validator_set;
                }
            }
        }
        get signed_header() {
            return pb_1.Message.getWrapperField(this, SignedHeader, 1) as SignedHeader;
        }
        set signed_header(value: SignedHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get validator_set() {
            return pb_1.Message.getWrapperField(this, ValidatorSet, 2) as ValidatorSet;
        }
        set validator_set(value: ValidatorSet) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            signed_header?: ReturnType<typeof SignedHeader.prototype.toObject>;
            validator_set?: ReturnType<typeof ValidatorSet.prototype.toObject>;
        }) {
            const message = new LightBlock({});
            if (data.signed_header != null) {
                message.signed_header = SignedHeader.fromObject(data.signed_header);
            }
            if (data.validator_set != null) {
                message.validator_set = ValidatorSet.fromObject(data.validator_set);
            }
            return message;
        }
        toObject() {
            const data: {
                signed_header?: ReturnType<typeof SignedHeader.prototype.toObject>;
                validator_set?: ReturnType<typeof ValidatorSet.prototype.toObject>;
            } = {};
            if (this.signed_header != null) {
                data.signed_header = this.signed_header.toObject();
            }
            if (this.validator_set != null) {
                data.validator_set = this.validator_set.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signed_header !== undefined)
                writer.writeMessage(1, this.signed_header, () => this.signed_header.serialize(writer));
            if (this.validator_set !== undefined)
                writer.writeMessage(2, this.validator_set, () => this.validator_set.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LightBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LightBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signed_header, () => message.signed_header = SignedHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.validator_set, () => message.validator_set = ValidatorSet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LightBlock {
            return LightBlock.deserialize(bytes);
        }
    }
    export class LightClientAttackEvidence extends pb_1.Message {
        constructor(data?: any[] | {
            conflicting_block?: LightBlock;
            common_height?: number;
            byzantine_validators?: Validator[];
            total_voting_power?: number;
            timestamp?: Timestamp;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("conflicting_block" in data && data.conflicting_block != undefined) {
                    this.conflicting_block = data.conflicting_block;
                }
                if ("common_height" in data && data.common_height != undefined) {
                    this.common_height = data.common_height;
                }
                if ("byzantine_validators" in data && data.byzantine_validators != undefined) {
                    this.byzantine_validators = data.byzantine_validators;
                }
                if ("total_voting_power" in data && data.total_voting_power != undefined) {
                    this.total_voting_power = data.total_voting_power;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
            }
        }
        get conflicting_block() {
            return pb_1.Message.getWrapperField(this, LightBlock, 1) as LightBlock;
        }
        set conflicting_block(value: LightBlock) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get common_height() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set common_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get byzantine_validators() {
            return pb_1.Message.getRepeatedWrapperField(this, Validator, 3) as Validator[];
        }
        set byzantine_validators(value: Validator[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get total_voting_power() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set total_voting_power(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, Timestamp, 5) as Timestamp;
        }
        set timestamp(value: Timestamp) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        static fromObject(data: {
            conflicting_block?: ReturnType<typeof LightBlock.prototype.toObject>;
            common_height?: number;
            byzantine_validators?: ReturnType<typeof Validator.prototype.toObject>[];
            total_voting_power?: number;
            timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
        }) {
            const message = new LightClientAttackEvidence({});
            if (data.conflicting_block != null) {
                message.conflicting_block = LightBlock.fromObject(data.conflicting_block);
            }
            if (data.common_height != null) {
                message.common_height = data.common_height;
            }
            if (data.byzantine_validators != null) {
                message.byzantine_validators = data.byzantine_validators.map(item => Validator.fromObject(item));
            }
            if (data.total_voting_power != null) {
                message.total_voting_power = data.total_voting_power;
            }
            if (data.timestamp != null) {
                message.timestamp = Timestamp.fromObject(data.timestamp);
            }
            return message;
        }
        toObject() {
            const data: {
                conflicting_block?: ReturnType<typeof LightBlock.prototype.toObject>;
                common_height?: number;
                byzantine_validators?: ReturnType<typeof Validator.prototype.toObject>[];
                total_voting_power?: number;
                timestamp?: ReturnType<typeof Timestamp.prototype.toObject>;
            } = {};
            if (this.conflicting_block != null) {
                data.conflicting_block = this.conflicting_block.toObject();
            }
            if (this.common_height != null) {
                data.common_height = this.common_height;
            }
            if (this.byzantine_validators != null) {
                data.byzantine_validators = this.byzantine_validators.map((item: Validator) => item.toObject());
            }
            if (this.total_voting_power != null) {
                data.total_voting_power = this.total_voting_power;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.conflicting_block !== undefined)
                writer.writeMessage(1, this.conflicting_block, () => this.conflicting_block.serialize(writer));
            if (this.common_height !== undefined)
                writer.writeInt64(2, this.common_height);
            if (this.byzantine_validators !== undefined)
                writer.writeRepeatedMessage(3, this.byzantine_validators, (item: Validator) => item.serialize(writer));
            if (this.total_voting_power !== undefined)
                writer.writeInt64(4, this.total_voting_power);
            if (this.timestamp !== undefined)
                writer.writeMessage(5, this.timestamp, () => this.timestamp.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LightClientAttackEvidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LightClientAttackEvidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.conflicting_block, () => message.conflicting_block = LightBlock.deserialize(reader));
                        break;
                    case 2:
                        message.common_height = reader.readInt64();
                        break;
                    case 3:
                        reader.readMessage(message.byzantine_validators, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Validator.deserialize(reader), Validator));
                        break;
                    case 4:
                        message.total_voting_power = reader.readInt64();
                        break;
                    case 5:
                        reader.readMessage(message.timestamp, () => message.timestamp = Timestamp.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LightClientAttackEvidence {
            return LightClientAttackEvidence.deserialize(bytes);
        }
    }
    export class PublicKey extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            ed25519?: Uint8Array;
            secp256k1?: never;
        } | {
            ed25519?: never;
            secp256k1?: Uint8Array;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("ed25519" in data && data.ed25519 != undefined) {
                    this.ed25519 = data.ed25519;
                }
                if ("secp256k1" in data && data.secp256k1 != undefined) {
                    this.secp256k1 = data.secp256k1;
                }
            }
        }
        get ed25519() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set ed25519(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 1, [1, 2], value);
        }
        get secp256k1() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set secp256k1(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 2, [1, 2], value);
        }
        get sum() {
            const cases: {
                [index: number]: "none" | "ed25519" | "secp256k1";
            } = {
                0: "none",
                1: "ed25519",
                2: "secp256k1"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            ed25519?: Uint8Array;
            secp256k1?: Uint8Array;
        }) {
            const message = new PublicKey({});
            if (data.ed25519 != null) {
                message.ed25519 = data.ed25519;
            }
            if (data.secp256k1 != null) {
                message.secp256k1 = data.secp256k1;
            }
            return message;
        }
        toObject() {
            const data: {
                ed25519?: Uint8Array;
                secp256k1?: Uint8Array;
            } = {};
            if (this.ed25519 != null) {
                data.ed25519 = this.ed25519;
            }
            if (this.secp256k1 != null) {
                data.secp256k1 = this.secp256k1;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ed25519 !== undefined)
                writer.writeBytes(1, this.ed25519);
            if (this.secp256k1 !== undefined)
                writer.writeBytes(2, this.secp256k1);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PublicKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PublicKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.ed25519 = reader.readBytes();
                        break;
                    case 2:
                        message.secp256k1 = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PublicKey {
            return PublicKey.deserialize(bytes);
        }
    }
    export class PartSetHeader extends pb_1.Message {
        constructor(data?: any[] | {
            total?: number;
            hash?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("total" in data && data.total != undefined) {
                    this.total = data.total;
                }
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
            }
        }
        get total() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set total(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get hash() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set hash(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            total?: number;
            hash?: Uint8Array;
        }) {
            const message = new PartSetHeader({});
            if (data.total != null) {
                message.total = data.total;
            }
            if (data.hash != null) {
                message.hash = data.hash;
            }
            return message;
        }
        toObject() {
            const data: {
                total?: number;
                hash?: Uint8Array;
            } = {};
            if (this.total != null) {
                data.total = this.total;
            }
            if (this.hash != null) {
                data.hash = this.hash;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.total !== undefined)
                writer.writeUint32(1, this.total);
            if (this.hash !== undefined)
                writer.writeBytes(2, this.hash);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PartSetHeader {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PartSetHeader();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.total = reader.readUint32();
                        break;
                    case 2:
                        message.hash = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PartSetHeader {
            return PartSetHeader.deserialize(bytes);
        }
    }
    export class ResponseBeginBlock extends pb_1.Message {
        constructor(data?: any[] | {
            events?: Event[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("events" in data && data.events != undefined) {
                    this.events = data.events;
                }
            }
        }
        get events() {
            return pb_1.Message.getRepeatedWrapperField(this, Event, 1) as Event[];
        }
        set events(value: Event[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            events?: ReturnType<typeof Event.prototype.toObject>[];
        }) {
            const message = new ResponseBeginBlock({});
            if (data.events != null) {
                message.events = data.events.map(item => Event.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                events?: ReturnType<typeof Event.prototype.toObject>[];
            } = {};
            if (this.events != null) {
                data.events = this.events.map((item: Event) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.events !== undefined)
                writer.writeRepeatedMessage(1, this.events, (item: Event) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResponseBeginBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResponseBeginBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.events, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Event.deserialize(reader), Event));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResponseBeginBlock {
            return ResponseBeginBlock.deserialize(bytes);
        }
    }
    export class ResponseEndBlock extends pb_1.Message {
        constructor(data?: any[] | {
            validator_updates?: ValidatorUpdate[];
            consensus_param_updates?: ConsensusParams;
            events?: Event[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validator_updates" in data && data.validator_updates != undefined) {
                    this.validator_updates = data.validator_updates;
                }
                if ("consensus_param_updates" in data && data.consensus_param_updates != undefined) {
                    this.consensus_param_updates = data.consensus_param_updates;
                }
                if ("events" in data && data.events != undefined) {
                    this.events = data.events;
                }
            }
        }
        get validator_updates() {
            return pb_1.Message.getRepeatedWrapperField(this, ValidatorUpdate, 1) as ValidatorUpdate[];
        }
        set validator_updates(value: ValidatorUpdate[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get consensus_param_updates() {
            return pb_1.Message.getWrapperField(this, ConsensusParams, 2) as ConsensusParams;
        }
        set consensus_param_updates(value: ConsensusParams) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get events() {
            return pb_1.Message.getRepeatedWrapperField(this, Event, 3) as Event[];
        }
        set events(value: Event[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            validator_updates?: ReturnType<typeof ValidatorUpdate.prototype.toObject>[];
            consensus_param_updates?: ReturnType<typeof ConsensusParams.prototype.toObject>;
            events?: ReturnType<typeof Event.prototype.toObject>[];
        }) {
            const message = new ResponseEndBlock({});
            if (data.validator_updates != null) {
                message.validator_updates = data.validator_updates.map(item => ValidatorUpdate.fromObject(item));
            }
            if (data.consensus_param_updates != null) {
                message.consensus_param_updates = ConsensusParams.fromObject(data.consensus_param_updates);
            }
            if (data.events != null) {
                message.events = data.events.map(item => Event.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                validator_updates?: ReturnType<typeof ValidatorUpdate.prototype.toObject>[];
                consensus_param_updates?: ReturnType<typeof ConsensusParams.prototype.toObject>;
                events?: ReturnType<typeof Event.prototype.toObject>[];
            } = {};
            if (this.validator_updates != null) {
                data.validator_updates = this.validator_updates.map((item: ValidatorUpdate) => item.toObject());
            }
            if (this.consensus_param_updates != null) {
                data.consensus_param_updates = this.consensus_param_updates.toObject();
            }
            if (this.events != null) {
                data.events = this.events.map((item: Event) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.validator_updates !== undefined)
                writer.writeRepeatedMessage(1, this.validator_updates, (item: ValidatorUpdate) => item.serialize(writer));
            if (this.consensus_param_updates !== undefined)
                writer.writeMessage(2, this.consensus_param_updates, () => this.consensus_param_updates.serialize(writer));
            if (this.events !== undefined)
                writer.writeRepeatedMessage(3, this.events, (item: Event) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResponseEndBlock {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResponseEndBlock();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.validator_updates, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ValidatorUpdate.deserialize(reader), ValidatorUpdate));
                        break;
                    case 2:
                        reader.readMessage(message.consensus_param_updates, () => message.consensus_param_updates = ConsensusParams.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.events, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Event.deserialize(reader), Event));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResponseEndBlock {
            return ResponseEndBlock.deserialize(bytes);
        }
    }
    export class ResponseDeliverTx extends pb_1.Message {
        constructor(data?: any[] | {
            code?: number;
            data?: Uint8Array;
            log?: string;
            info?: string;
            gas_wanted?: number;
            gas_used?: number;
            events?: Event[];
            codespace?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [7], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("code" in data && data.code != undefined) {
                    this.code = data.code;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("log" in data && data.log != undefined) {
                    this.log = data.log;
                }
                if ("info" in data && data.info != undefined) {
                    this.info = data.info;
                }
                if ("gas_wanted" in data && data.gas_wanted != undefined) {
                    this.gas_wanted = data.gas_wanted;
                }
                if ("gas_used" in data && data.gas_used != undefined) {
                    this.gas_used = data.gas_used;
                }
                if ("events" in data && data.events != undefined) {
                    this.events = data.events;
                }
                if ("codespace" in data && data.codespace != undefined) {
                    this.codespace = data.codespace;
                }
            }
        }
        get code() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set code(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get data() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set data(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get log() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set log(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get info() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set info(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get gas_wanted() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set gas_wanted(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get gas_used() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set gas_used(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get events() {
            return pb_1.Message.getRepeatedWrapperField(this, Event, 7) as Event[];
        }
        set events(value: Event[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get codespace() {
            return pb_1.Message.getField(this, 8) as string;
        }
        set codespace(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            code?: number;
            data?: Uint8Array;
            log?: string;
            info?: string;
            gas_wanted?: number;
            gas_used?: number;
            events?: ReturnType<typeof Event.prototype.toObject>[];
            codespace?: string;
        }) {
            const message = new ResponseDeliverTx({});
            if (data.code != null) {
                message.code = data.code;
            }
            if (data.data != null) {
                message.data = data.data;
            }
            if (data.log != null) {
                message.log = data.log;
            }
            if (data.info != null) {
                message.info = data.info;
            }
            if (data.gas_wanted != null) {
                message.gas_wanted = data.gas_wanted;
            }
            if (data.gas_used != null) {
                message.gas_used = data.gas_used;
            }
            if (data.events != null) {
                message.events = data.events.map(item => Event.fromObject(item));
            }
            if (data.codespace != null) {
                message.codespace = data.codespace;
            }
            return message;
        }
        toObject() {
            const data: {
                code?: number;
                data?: Uint8Array;
                log?: string;
                info?: string;
                gas_wanted?: number;
                gas_used?: number;
                events?: ReturnType<typeof Event.prototype.toObject>[];
                codespace?: string;
            } = {};
            if (this.code != null) {
                data.code = this.code;
            }
            if (this.data != null) {
                data.data = this.data;
            }
            if (this.log != null) {
                data.log = this.log;
            }
            if (this.info != null) {
                data.info = this.info;
            }
            if (this.gas_wanted != null) {
                data.gas_wanted = this.gas_wanted;
            }
            if (this.gas_used != null) {
                data.gas_used = this.gas_used;
            }
            if (this.events != null) {
                data.events = this.events.map((item: Event) => item.toObject());
            }
            if (this.codespace != null) {
                data.codespace = this.codespace;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.code !== undefined)
                writer.writeUint32(1, this.code);
            if (this.data !== undefined)
                writer.writeBytes(2, this.data);
            if (typeof this.log === "string" && this.log.length)
                writer.writeString(3, this.log);
            if (typeof this.info === "string" && this.info.length)
                writer.writeString(4, this.info);
            if (this.gas_wanted !== undefined)
                writer.writeInt64(5, this.gas_wanted);
            if (this.gas_used !== undefined)
                writer.writeInt64(6, this.gas_used);
            if (this.events !== undefined)
                writer.writeRepeatedMessage(7, this.events, (item: Event) => item.serialize(writer));
            if (typeof this.codespace === "string" && this.codespace.length)
                writer.writeString(8, this.codespace);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResponseDeliverTx {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResponseDeliverTx();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.code = reader.readUint32();
                        break;
                    case 2:
                        message.data = reader.readBytes();
                        break;
                    case 3:
                        message.log = reader.readString();
                        break;
                    case 4:
                        message.info = reader.readString();
                        break;
                    case 5:
                        message.gas_wanted = reader.readInt64();
                        break;
                    case 6:
                        message.gas_used = reader.readInt64();
                        break;
                    case 7:
                        reader.readMessage(message.events, () => pb_1.Message.addToRepeatedWrapperField(message, 7, Event.deserialize(reader), Event));
                        break;
                    case 8:
                        message.codespace = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResponseDeliverTx {
            return ResponseDeliverTx.deserialize(bytes);
        }
    }
    export class SignedHeader extends pb_1.Message {
        constructor(data?: any[] | {
            header?: Header;
            commit?: Commit;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("commit" in data && data.commit != undefined) {
                    this.commit = data.commit;
                }
            }
        }
        get header() {
            return pb_1.Message.getWrapperField(this, Header, 1) as Header;
        }
        set header(value: Header) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get commit() {
            return pb_1.Message.getWrapperField(this, Commit, 2) as Commit;
        }
        set commit(value: Commit) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            header?: ReturnType<typeof Header.prototype.toObject>;
            commit?: ReturnType<typeof Commit.prototype.toObject>;
        }) {
            const message = new SignedHeader({});
            if (data.header != null) {
                message.header = Header.fromObject(data.header);
            }
            if (data.commit != null) {
                message.commit = Commit.fromObject(data.commit);
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof Header.prototype.toObject>;
                commit?: ReturnType<typeof Commit.prototype.toObject>;
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.commit != null) {
                data.commit = this.commit.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.header !== undefined)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            if (this.commit !== undefined)
                writer.writeMessage(2, this.commit, () => this.commit.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignedHeader {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignedHeader();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = Header.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.commit, () => message.commit = Commit.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignedHeader {
            return SignedHeader.deserialize(bytes);
        }
    }
    export class Timestamp extends pb_1.Message {
        constructor(data?: any[] | {
            seconds?: number;
            nanos?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("seconds" in data && data.seconds != undefined) {
                    this.seconds = data.seconds;
                }
                if ("nanos" in data && data.nanos != undefined) {
                    this.nanos = data.nanos;
                }
            }
        }
        get seconds() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set seconds(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get nanos() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set nanos(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            seconds?: number;
            nanos?: number;
        }) {
            const message = new Timestamp({});
            if (data.seconds != null) {
                message.seconds = data.seconds;
            }
            if (data.nanos != null) {
                message.nanos = data.nanos;
            }
            return message;
        }
        toObject() {
            const data: {
                seconds?: number;
                nanos?: number;
            } = {};
            if (this.seconds != null) {
                data.seconds = this.seconds;
            }
            if (this.nanos != null) {
                data.nanos = this.nanos;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.seconds !== undefined)
                writer.writeInt64(1, this.seconds);
            if (this.nanos !== undefined)
                writer.writeInt32(2, this.nanos);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Timestamp {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Timestamp();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.seconds = reader.readInt64();
                        break;
                    case 2:
                        message.nanos = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Timestamp {
            return Timestamp.deserialize(bytes);
        }
    }
    export class TxResult extends pb_1.Message {
        constructor(data?: any[] | {
            height?: number;
            index?: number;
            tx?: Uint8Array;
            result?: ResponseDeliverTx;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("height" in data && data.height != undefined) {
                    this.height = data.height;
                }
                if ("index" in data && data.index != undefined) {
                    this.index = data.index;
                }
                if ("tx" in data && data.tx != undefined) {
                    this.tx = data.tx;
                }
                if ("result" in data && data.result != undefined) {
                    this.result = data.result;
                }
            }
        }
        get height() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set height(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get index() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set index(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get tx() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set tx(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get result() {
            return pb_1.Message.getWrapperField(this, ResponseDeliverTx, 4) as ResponseDeliverTx;
        }
        set result(value: ResponseDeliverTx) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            height?: number;
            index?: number;
            tx?: Uint8Array;
            result?: ReturnType<typeof ResponseDeliverTx.prototype.toObject>;
        }) {
            const message = new TxResult({});
            if (data.height != null) {
                message.height = data.height;
            }
            if (data.index != null) {
                message.index = data.index;
            }
            if (data.tx != null) {
                message.tx = data.tx;
            }
            if (data.result != null) {
                message.result = ResponseDeliverTx.fromObject(data.result);
            }
            return message;
        }
        toObject() {
            const data: {
                height?: number;
                index?: number;
                tx?: Uint8Array;
                result?: ReturnType<typeof ResponseDeliverTx.prototype.toObject>;
            } = {};
            if (this.height != null) {
                data.height = this.height;
            }
            if (this.index != null) {
                data.index = this.index;
            }
            if (this.tx != null) {
                data.tx = this.tx;
            }
            if (this.result != null) {
                data.result = this.result.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.height !== undefined)
                writer.writeUint64(1, this.height);
            if (this.index !== undefined)
                writer.writeUint32(2, this.index);
            if (this.tx !== undefined)
                writer.writeBytes(3, this.tx);
            if (this.result !== undefined)
                writer.writeMessage(4, this.result, () => this.result.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.height = reader.readUint64();
                        break;
                    case 2:
                        message.index = reader.readUint32();
                        break;
                    case 3:
                        message.tx = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.result, () => message.result = ResponseDeliverTx.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxResult {
            return TxResult.deserialize(bytes);
        }
    }
    export class Validator extends pb_1.Message {
        constructor(data?: any[] | {
            address?: Uint8Array;
            pub_key?: PublicKey;
            voting_power?: number;
            proposer_priority?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("pub_key" in data && data.pub_key != undefined) {
                    this.pub_key = data.pub_key;
                }
                if ("voting_power" in data && data.voting_power != undefined) {
                    this.voting_power = data.voting_power;
                }
                if ("proposer_priority" in data && data.proposer_priority != undefined) {
                    this.proposer_priority = data.proposer_priority;
                }
            }
        }
        get address() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set address(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get pub_key() {
            return pb_1.Message.getWrapperField(this, PublicKey, 2) as PublicKey;
        }
        set pub_key(value: PublicKey) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get voting_power() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set voting_power(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get proposer_priority() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set proposer_priority(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            address?: Uint8Array;
            pub_key?: ReturnType<typeof PublicKey.prototype.toObject>;
            voting_power?: number;
            proposer_priority?: number;
        }) {
            const message = new Validator({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.pub_key != null) {
                message.pub_key = PublicKey.fromObject(data.pub_key);
            }
            if (data.voting_power != null) {
                message.voting_power = data.voting_power;
            }
            if (data.proposer_priority != null) {
                message.proposer_priority = data.proposer_priority;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: Uint8Array;
                pub_key?: ReturnType<typeof PublicKey.prototype.toObject>;
                voting_power?: number;
                proposer_priority?: number;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.pub_key != null) {
                data.pub_key = this.pub_key.toObject();
            }
            if (this.voting_power != null) {
                data.voting_power = this.voting_power;
            }
            if (this.proposer_priority != null) {
                data.proposer_priority = this.proposer_priority;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address !== undefined)
                writer.writeBytes(1, this.address);
            if (this.pub_key !== undefined)
                writer.writeMessage(2, this.pub_key, () => this.pub_key.serialize(writer));
            if (this.voting_power !== undefined)
                writer.writeInt64(3, this.voting_power);
            if (this.proposer_priority !== undefined)
                writer.writeInt64(4, this.proposer_priority);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Validator {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Validator();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.pub_key, () => message.pub_key = PublicKey.deserialize(reader));
                        break;
                    case 3:
                        message.voting_power = reader.readInt64();
                        break;
                    case 4:
                        message.proposer_priority = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Validator {
            return Validator.deserialize(bytes);
        }
    }
    export class ValidatorParams extends pb_1.Message {
        constructor(data?: any[] | {
            pub_key_types?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("pub_key_types" in data && data.pub_key_types != undefined) {
                    this.pub_key_types = data.pub_key_types;
                }
            }
        }
        get pub_key_types() {
            return pb_1.Message.getField(this, 1) as string[];
        }
        set pub_key_types(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            pub_key_types?: string[];
        }) {
            const message = new ValidatorParams({});
            if (data.pub_key_types != null) {
                message.pub_key_types = data.pub_key_types;
            }
            return message;
        }
        toObject() {
            const data: {
                pub_key_types?: string[];
            } = {};
            if (this.pub_key_types != null) {
                data.pub_key_types = this.pub_key_types;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.pub_key_types !== undefined)
                writer.writeRepeatedString(1, this.pub_key_types);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValidatorParams {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValidatorParams();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ValidatorParams {
            return ValidatorParams.deserialize(bytes);
        }
    }
    export class ValidatorSet extends pb_1.Message {
        constructor(data?: any[] | {
            validators?: Validator[];
            proposer?: Validator;
            total_voting_power?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validators" in data && data.validators != undefined) {
                    this.validators = data.validators;
                }
                if ("proposer" in data && data.proposer != undefined) {
                    this.proposer = data.proposer;
                }
                if ("total_voting_power" in data && data.total_voting_power != undefined) {
                    this.total_voting_power = data.total_voting_power;
                }
            }
        }
        get validators() {
            return pb_1.Message.getRepeatedWrapperField(this, Validator, 1) as Validator[];
        }
        set validators(value: Validator[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get proposer() {
            return pb_1.Message.getWrapperField(this, Validator, 2) as Validator;
        }
        set proposer(value: Validator) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get total_voting_power() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set total_voting_power(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            validators?: ReturnType<typeof Validator.prototype.toObject>[];
            proposer?: ReturnType<typeof Validator.prototype.toObject>;
            total_voting_power?: number;
        }) {
            const message = new ValidatorSet({});
            if (data.validators != null) {
                message.validators = data.validators.map(item => Validator.fromObject(item));
            }
            if (data.proposer != null) {
                message.proposer = Validator.fromObject(data.proposer);
            }
            if (data.total_voting_power != null) {
                message.total_voting_power = data.total_voting_power;
            }
            return message;
        }
        toObject() {
            const data: {
                validators?: ReturnType<typeof Validator.prototype.toObject>[];
                proposer?: ReturnType<typeof Validator.prototype.toObject>;
                total_voting_power?: number;
            } = {};
            if (this.validators != null) {
                data.validators = this.validators.map((item: Validator) => item.toObject());
            }
            if (this.proposer != null) {
                data.proposer = this.proposer.toObject();
            }
            if (this.total_voting_power != null) {
                data.total_voting_power = this.total_voting_power;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.validators !== undefined)
                writer.writeRepeatedMessage(1, this.validators, (item: Validator) => item.serialize(writer));
            if (this.proposer !== undefined)
                writer.writeMessage(2, this.proposer, () => this.proposer.serialize(writer));
            if (this.total_voting_power !== undefined)
                writer.writeInt64(3, this.total_voting_power);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValidatorSet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValidatorSet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.validators, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Validator.deserialize(reader), Validator));
                        break;
                    case 2:
                        reader.readMessage(message.proposer, () => message.proposer = Validator.deserialize(reader));
                        break;
                    case 3:
                        message.total_voting_power = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ValidatorSet {
            return ValidatorSet.deserialize(bytes);
        }
    }
    export class ValidatorUpdate extends pb_1.Message {
        constructor(data?: any[] | {
            address?: Uint8Array;
            pub_key?: PublicKey;
            power?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("pub_key" in data && data.pub_key != undefined) {
                    this.pub_key = data.pub_key;
                }
                if ("power" in data && data.power != undefined) {
                    this.power = data.power;
                }
            }
        }
        get address() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set address(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get pub_key() {
            return pb_1.Message.getWrapperField(this, PublicKey, 2) as PublicKey;
        }
        set pub_key(value: PublicKey) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get power() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set power(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            address?: Uint8Array;
            pub_key?: ReturnType<typeof PublicKey.prototype.toObject>;
            power?: number;
        }) {
            const message = new ValidatorUpdate({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.pub_key != null) {
                message.pub_key = PublicKey.fromObject(data.pub_key);
            }
            if (data.power != null) {
                message.power = data.power;
            }
            return message;
        }
        toObject() {
            const data: {
                address?: Uint8Array;
                pub_key?: ReturnType<typeof PublicKey.prototype.toObject>;
                power?: number;
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.pub_key != null) {
                data.pub_key = this.pub_key.toObject();
            }
            if (this.power != null) {
                data.power = this.power;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.address !== undefined)
                writer.writeBytes(1, this.address);
            if (this.pub_key !== undefined)
                writer.writeMessage(2, this.pub_key, () => this.pub_key.serialize(writer));
            if (this.power !== undefined)
                writer.writeInt64(3, this.power);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ValidatorUpdate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ValidatorUpdate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readBytes();
                        break;
                    case 2:
                        reader.readMessage(message.pub_key, () => message.pub_key = PublicKey.deserialize(reader));
                        break;
                    case 3:
                        message.power = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ValidatorUpdate {
            return ValidatorUpdate.deserialize(bytes);
        }
    }
    export class VersionParams extends pb_1.Message {
        constructor(data?: any[] | {
            app_version?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("app_version" in data && data.app_version != undefined) {
                    this.app_version = data.app_version;
                }
            }
        }
        get app_version() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set app_version(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            app_version?: number;
        }) {
            const message = new VersionParams({});
            if (data.app_version != null) {
                message.app_version = data.app_version;
            }
            return message;
        }
        toObject() {
            const data: {
                app_version?: number;
            } = {};
            if (this.app_version != null) {
                data.app_version = this.app_version;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.app_version !== undefined)
                writer.writeUint64(1, this.app_version);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): VersionParams {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new VersionParams();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.app_version = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): VersionParams {
            return VersionParams.deserialize(bytes);
        }
    }
}
