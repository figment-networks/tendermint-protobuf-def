/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.4
 * source: cosmos.v1.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./codec";
import * as dependency_2 from "./gogo";
import * as dependency_3 from "./google/protobuf/descriptor";
import * as pb_1 from "google-protobuf";
export namespace cosmos.v1 {
    export enum SignMode {
        SIGN_MODE_UNSPECIFIED = 0,
        SIGN_MODE_DIRECT = 1,
        SIGN_MODE_TEXTUAL = 2,
        SIGN_MODE_DIRECT_AUX = 3,
        SIGN_MODE_LEGACY_AMINO_JSON = 127
    }
    export enum State {
        STATE_UNINITIALIZED_UNSPECIFIED = 0,
        STATE_INIT = 1,
        STATE_TRYOPEN = 2,
        STATE_OPEN = 3,
        STATE_CLOSED = 4
    }
    export enum Order {
        ORDER_NONE_UNSPECIFIED = 0,
        ORDER_UNORDERED = 1,
        ORDER_ORDERED = 2
    }
    export enum VoteOption {
        VOTE_OPTION_UNSPECIFIED = 0,
        VOTE_OPTION_YES = 1,
        VOTE_OPTION_ABSTAIN = 2,
        VOTE_OPTION_NO = 3,
        VOTE_OPTION_NO_WITH_VETO = 4
    }
    export class Tx extends pb_1.Message {
        constructor(data?: any[] | {
            body?: TxBody;
            auth_info?: AuthInfo;
            signatures?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("body" in data && data.body != undefined) {
                    this.body = data.body;
                }
                if ("auth_info" in data && data.auth_info != undefined) {
                    this.auth_info = data.auth_info;
                }
                if ("signatures" in data && data.signatures != undefined) {
                    this.signatures = data.signatures;
                }
            }
        }
        get body() {
            return pb_1.Message.getWrapperField(this, TxBody, 1) as TxBody;
        }
        set body(value: TxBody) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get auth_info() {
            return pb_1.Message.getWrapperField(this, AuthInfo, 2) as AuthInfo;
        }
        set auth_info(value: AuthInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signatures() {
            return pb_1.Message.getField(this, 3) as Uint8Array[];
        }
        set signatures(value: Uint8Array[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            body?: ReturnType<typeof TxBody.prototype.toObject>;
            auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
            signatures?: Uint8Array[];
        }) {
            const message = new Tx({});
            if (data.body != null) {
                message.body = TxBody.fromObject(data.body);
            }
            if (data.auth_info != null) {
                message.auth_info = AuthInfo.fromObject(data.auth_info);
            }
            if (data.signatures != null) {
                message.signatures = data.signatures;
            }
            return message;
        }
        toObject() {
            const data: {
                body?: ReturnType<typeof TxBody.prototype.toObject>;
                auth_info?: ReturnType<typeof AuthInfo.prototype.toObject>;
                signatures?: Uint8Array[];
            } = {};
            if (this.body != null) {
                data.body = this.body.toObject();
            }
            if (this.auth_info != null) {
                data.auth_info = this.auth_info.toObject();
            }
            if (this.signatures != null) {
                data.signatures = this.signatures;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.body !== undefined)
                writer.writeMessage(1, this.body, () => this.body.serialize(writer));
            if (this.auth_info !== undefined)
                writer.writeMessage(2, this.auth_info, () => this.auth_info.serialize(writer));
            if (this.signatures !== undefined)
                writer.writeRepeatedBytes(3, this.signatures);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tx {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tx();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.body, () => message.body = TxBody.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.auth_info, () => message.auth_info = AuthInfo.deserialize(reader));
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tx {
            return Tx.deserialize(bytes);
        }
    }
    export class TxBody extends pb_1.Message {
        constructor(data?: any[] | {
            messages?: Any[];
            memo?: string;
            timeout_height?: number;
            extension_options?: Any[];
            non_critical_extension_options?: Any[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 1023, 2047], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("messages" in data && data.messages != undefined) {
                    this.messages = data.messages;
                }
                if ("memo" in data && data.memo != undefined) {
                    this.memo = data.memo;
                }
                if ("timeout_height" in data && data.timeout_height != undefined) {
                    this.timeout_height = data.timeout_height;
                }
                if ("extension_options" in data && data.extension_options != undefined) {
                    this.extension_options = data.extension_options;
                }
                if ("non_critical_extension_options" in data && data.non_critical_extension_options != undefined) {
                    this.non_critical_extension_options = data.non_critical_extension_options;
                }
            }
        }
        get messages() {
            return pb_1.Message.getRepeatedWrapperField(this, Any, 1) as Any[];
        }
        set messages(value: Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get memo() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set memo(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get timeout_height() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set timeout_height(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, Any, 1023) as Any[];
        }
        set extension_options(value: Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1023, value);
        }
        get non_critical_extension_options() {
            return pb_1.Message.getRepeatedWrapperField(this, Any, 2047) as Any[];
        }
        set non_critical_extension_options(value: Any[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2047, value);
        }
        static fromObject(data: {
            messages?: ReturnType<typeof Any.prototype.toObject>[];
            memo?: string;
            timeout_height?: number;
            extension_options?: ReturnType<typeof Any.prototype.toObject>[];
            non_critical_extension_options?: ReturnType<typeof Any.prototype.toObject>[];
        }) {
            const message = new TxBody({});
            if (data.messages != null) {
                message.messages = data.messages.map(item => Any.fromObject(item));
            }
            if (data.memo != null) {
                message.memo = data.memo;
            }
            if (data.timeout_height != null) {
                message.timeout_height = data.timeout_height;
            }
            if (data.extension_options != null) {
                message.extension_options = data.extension_options.map(item => Any.fromObject(item));
            }
            if (data.non_critical_extension_options != null) {
                message.non_critical_extension_options = data.non_critical_extension_options.map(item => Any.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                messages?: ReturnType<typeof Any.prototype.toObject>[];
                memo?: string;
                timeout_height?: number;
                extension_options?: ReturnType<typeof Any.prototype.toObject>[];
                non_critical_extension_options?: ReturnType<typeof Any.prototype.toObject>[];
            } = {};
            if (this.messages != null) {
                data.messages = this.messages.map((item: Any) => item.toObject());
            }
            if (this.memo != null) {
                data.memo = this.memo;
            }
            if (this.timeout_height != null) {
                data.timeout_height = this.timeout_height;
            }
            if (this.extension_options != null) {
                data.extension_options = this.extension_options.map((item: Any) => item.toObject());
            }
            if (this.non_critical_extension_options != null) {
                data.non_critical_extension_options = this.non_critical_extension_options.map((item: Any) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.messages !== undefined)
                writer.writeRepeatedMessage(1, this.messages, (item: Any) => item.serialize(writer));
            if (typeof this.memo === "string" && this.memo.length)
                writer.writeString(2, this.memo);
            if (this.timeout_height !== undefined)
                writer.writeUint64(3, this.timeout_height);
            if (this.extension_options !== undefined)
                writer.writeRepeatedMessage(1023, this.extension_options, (item: Any) => item.serialize(writer));
            if (this.non_critical_extension_options !== undefined)
                writer.writeRepeatedMessage(2047, this.non_critical_extension_options, (item: Any) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TxBody {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TxBody();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.messages, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Any.deserialize(reader), Any));
                        break;
                    case 2:
                        message.memo = reader.readString();
                        break;
                    case 3:
                        message.timeout_height = reader.readUint64();
                        break;
                    case 1023:
                        reader.readMessage(message.extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 1023, Any.deserialize(reader), Any));
                        break;
                    case 2047:
                        reader.readMessage(message.non_critical_extension_options, () => pb_1.Message.addToRepeatedWrapperField(message, 2047, Any.deserialize(reader), Any));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TxBody {
            return TxBody.deserialize(bytes);
        }
    }
    export class AuthInfo extends pb_1.Message {
        constructor(data?: any[] | {
            signer_infos?: SignerInfo[];
            fee?: Fee;
            tip?: Tip;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signer_infos" in data && data.signer_infos != undefined) {
                    this.signer_infos = data.signer_infos;
                }
                if ("fee" in data && data.fee != undefined) {
                    this.fee = data.fee;
                }
                if ("tip" in data && data.tip != undefined) {
                    this.tip = data.tip;
                }
            }
        }
        get signer_infos() {
            return pb_1.Message.getRepeatedWrapperField(this, SignerInfo, 1) as SignerInfo[];
        }
        set signer_infos(value: SignerInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get fee() {
            return pb_1.Message.getWrapperField(this, Fee, 2) as Fee;
        }
        set fee(value: Fee) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get tip() {
            return pb_1.Message.getWrapperField(this, Tip, 3) as Tip;
        }
        set tip(value: Tip) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
            fee?: ReturnType<typeof Fee.prototype.toObject>;
            tip?: ReturnType<typeof Tip.prototype.toObject>;
        }) {
            const message = new AuthInfo({});
            if (data.signer_infos != null) {
                message.signer_infos = data.signer_infos.map(item => SignerInfo.fromObject(item));
            }
            if (data.fee != null) {
                message.fee = Fee.fromObject(data.fee);
            }
            if (data.tip != null) {
                message.tip = Tip.fromObject(data.tip);
            }
            return message;
        }
        toObject() {
            const data: {
                signer_infos?: ReturnType<typeof SignerInfo.prototype.toObject>[];
                fee?: ReturnType<typeof Fee.prototype.toObject>;
                tip?: ReturnType<typeof Tip.prototype.toObject>;
            } = {};
            if (this.signer_infos != null) {
                data.signer_infos = this.signer_infos.map((item: SignerInfo) => item.toObject());
            }
            if (this.fee != null) {
                data.fee = this.fee.toObject();
            }
            if (this.tip != null) {
                data.tip = this.tip.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signer_infos !== undefined)
                writer.writeRepeatedMessage(1, this.signer_infos, (item: SignerInfo) => item.serialize(writer));
            if (this.fee !== undefined)
                writer.writeMessage(2, this.fee, () => this.fee.serialize(writer));
            if (this.tip !== undefined)
                writer.writeMessage(3, this.tip, () => this.tip.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuthInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AuthInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signer_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SignerInfo.deserialize(reader), SignerInfo));
                        break;
                    case 2:
                        reader.readMessage(message.fee, () => message.fee = Fee.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.tip, () => message.tip = Tip.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AuthInfo {
            return AuthInfo.deserialize(bytes);
        }
    }
    export class SignerInfo extends pb_1.Message {
        constructor(data?: any[] | {
            public_key?: Any;
            mode_info?: ModeInfo;
            sequence?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("public_key" in data && data.public_key != undefined) {
                    this.public_key = data.public_key;
                }
                if ("mode_info" in data && data.mode_info != undefined) {
                    this.mode_info = data.mode_info;
                }
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
            }
        }
        get public_key() {
            return pb_1.Message.getWrapperField(this, Any, 1) as Any;
        }
        set public_key(value: Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get mode_info() {
            return pb_1.Message.getWrapperField(this, ModeInfo, 2) as ModeInfo;
        }
        set mode_info(value: ModeInfo) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get sequence() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            public_key?: ReturnType<typeof Any.prototype.toObject>;
            mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
            sequence?: number;
        }) {
            const message = new SignerInfo({});
            if (data.public_key != null) {
                message.public_key = Any.fromObject(data.public_key);
            }
            if (data.mode_info != null) {
                message.mode_info = ModeInfo.fromObject(data.mode_info);
            }
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            return message;
        }
        toObject() {
            const data: {
                public_key?: ReturnType<typeof Any.prototype.toObject>;
                mode_info?: ReturnType<typeof ModeInfo.prototype.toObject>;
                sequence?: number;
            } = {};
            if (this.public_key != null) {
                data.public_key = this.public_key.toObject();
            }
            if (this.mode_info != null) {
                data.mode_info = this.mode_info.toObject();
            }
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.public_key !== undefined)
                writer.writeMessage(1, this.public_key, () => this.public_key.serialize(writer));
            if (this.mode_info !== undefined)
                writer.writeMessage(2, this.mode_info, () => this.mode_info.serialize(writer));
            if (this.sequence !== undefined)
                writer.writeUint64(3, this.sequence);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SignerInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SignerInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.public_key, () => message.public_key = Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.mode_info, () => message.mode_info = ModeInfo.deserialize(reader));
                        break;
                    case 3:
                        message.sequence = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SignerInfo {
            return SignerInfo.deserialize(bytes);
        }
    }
    export class ModeInfo extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            single?: Single;
            multi?: never;
        } | {
            single?: never;
            multi?: Multi;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("single" in data && data.single != undefined) {
                    this.single = data.single;
                }
                if ("multi" in data && data.multi != undefined) {
                    this.multi = data.multi;
                }
            }
        }
        get single() {
            return pb_1.Message.getWrapperField(this, Single, 1) as Single;
        }
        set single(value: Single) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2], value);
        }
        get multi() {
            return pb_1.Message.getWrapperField(this, Multi, 2) as Multi;
        }
        set multi(value: Multi) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2], value);
        }
        get sum() {
            const cases: {
                [index: number]: "none" | "single" | "multi";
            } = {
                0: "none",
                1: "single",
                2: "multi"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            single?: ReturnType<typeof Single.prototype.toObject>;
            multi?: ReturnType<typeof Multi.prototype.toObject>;
        }) {
            const message = new ModeInfo({});
            if (data.single != null) {
                message.single = Single.fromObject(data.single);
            }
            if (data.multi != null) {
                message.multi = Multi.fromObject(data.multi);
            }
            return message;
        }
        toObject() {
            const data: {
                single?: ReturnType<typeof Single.prototype.toObject>;
                multi?: ReturnType<typeof Multi.prototype.toObject>;
            } = {};
            if (this.single != null) {
                data.single = this.single.toObject();
            }
            if (this.multi != null) {
                data.multi = this.multi.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.single !== undefined)
                writer.writeMessage(1, this.single, () => this.single.serialize(writer));
            if (this.multi !== undefined)
                writer.writeMessage(2, this.multi, () => this.multi.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ModeInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ModeInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.single, () => message.single = Single.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.multi, () => message.multi = Multi.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ModeInfo {
            return ModeInfo.deserialize(bytes);
        }
    }
    export class Single extends pb_1.Message {
        constructor(data?: any[] | {
            mode?: SignMode;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("mode" in data && data.mode != undefined) {
                    this.mode = data.mode;
                }
            }
        }
        get mode() {
            return pb_1.Message.getField(this, 1) as SignMode;
        }
        set mode(value: SignMode) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            mode?: SignMode;
        }) {
            const message = new Single({});
            if (data.mode != null) {
                message.mode = data.mode;
            }
            return message;
        }
        toObject() {
            const data: {
                mode?: SignMode;
            } = {};
            if (this.mode != null) {
                data.mode = this.mode;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.mode !== undefined)
                writer.writeEnum(1, this.mode);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Single {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Single();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.mode = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Single {
            return Single.deserialize(bytes);
        }
    }
    export class Multi extends pb_1.Message {
        constructor(data?: any[] | {
            bitarray?: CompactBitArray;
            mode_infos?: ModeInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("bitarray" in data && data.bitarray != undefined) {
                    this.bitarray = data.bitarray;
                }
                if ("mode_infos" in data && data.mode_infos != undefined) {
                    this.mode_infos = data.mode_infos;
                }
            }
        }
        get bitarray() {
            return pb_1.Message.getWrapperField(this, CompactBitArray, 1) as CompactBitArray;
        }
        set bitarray(value: CompactBitArray) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get mode_infos() {
            return pb_1.Message.getRepeatedWrapperField(this, ModeInfo, 2) as ModeInfo[];
        }
        set mode_infos(value: ModeInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            bitarray?: ReturnType<typeof CompactBitArray.prototype.toObject>;
            mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
        }) {
            const message = new Multi({});
            if (data.bitarray != null) {
                message.bitarray = CompactBitArray.fromObject(data.bitarray);
            }
            if (data.mode_infos != null) {
                message.mode_infos = data.mode_infos.map(item => ModeInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                bitarray?: ReturnType<typeof CompactBitArray.prototype.toObject>;
                mode_infos?: ReturnType<typeof ModeInfo.prototype.toObject>[];
            } = {};
            if (this.bitarray != null) {
                data.bitarray = this.bitarray.toObject();
            }
            if (this.mode_infos != null) {
                data.mode_infos = this.mode_infos.map((item: ModeInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.bitarray !== undefined)
                writer.writeMessage(1, this.bitarray, () => this.bitarray.serialize(writer));
            if (this.mode_infos !== undefined)
                writer.writeRepeatedMessage(2, this.mode_infos, (item: ModeInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Multi {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Multi();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.bitarray, () => message.bitarray = CompactBitArray.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.mode_infos, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ModeInfo.deserialize(reader), ModeInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Multi {
            return Multi.deserialize(bytes);
        }
    }
    export class CompactBitArray extends pb_1.Message {
        constructor(data?: any[] | {
            extra_bits_stored?: number;
            elems?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("extra_bits_stored" in data && data.extra_bits_stored != undefined) {
                    this.extra_bits_stored = data.extra_bits_stored;
                }
                if ("elems" in data && data.elems != undefined) {
                    this.elems = data.elems;
                }
            }
        }
        get extra_bits_stored() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set extra_bits_stored(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get elems() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set elems(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            extra_bits_stored?: number;
            elems?: Uint8Array;
        }) {
            const message = new CompactBitArray({});
            if (data.extra_bits_stored != null) {
                message.extra_bits_stored = data.extra_bits_stored;
            }
            if (data.elems != null) {
                message.elems = data.elems;
            }
            return message;
        }
        toObject() {
            const data: {
                extra_bits_stored?: number;
                elems?: Uint8Array;
            } = {};
            if (this.extra_bits_stored != null) {
                data.extra_bits_stored = this.extra_bits_stored;
            }
            if (this.elems != null) {
                data.elems = this.elems;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.extra_bits_stored !== undefined)
                writer.writeUint32(1, this.extra_bits_stored);
            if (this.elems !== undefined)
                writer.writeBytes(2, this.elems);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CompactBitArray {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CompactBitArray();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.extra_bits_stored = reader.readUint32();
                        break;
                    case 2:
                        message.elems = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CompactBitArray {
            return CompactBitArray.deserialize(bytes);
        }
    }
    export class Fee extends pb_1.Message {
        constructor(data?: any[] | {
            amount?: Coin[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("gas_limit" in data && data.gas_limit != undefined) {
                    this.gas_limit = data.gas_limit;
                }
                if ("payer" in data && data.payer != undefined) {
                    this.payer = data.payer;
                }
                if ("granter" in data && data.granter != undefined) {
                    this.granter = data.granter;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 1) as Coin[];
        }
        set amount(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get gas_limit() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set gas_limit(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get payer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set payer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get granter() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set granter(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof Coin.prototype.toObject>[];
            gas_limit?: number;
            payer?: string;
            granter?: string;
        }) {
            const message = new Fee({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => Coin.fromObject(item));
            }
            if (data.gas_limit != null) {
                message.gas_limit = data.gas_limit;
            }
            if (data.payer != null) {
                message.payer = data.payer;
            }
            if (data.granter != null) {
                message.granter = data.granter;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof Coin.prototype.toObject>[];
                gas_limit?: number;
                payer?: string;
                granter?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: Coin) => item.toObject());
            }
            if (this.gas_limit != null) {
                data.gas_limit = this.gas_limit;
            }
            if (this.payer != null) {
                data.payer = this.payer;
            }
            if (this.granter != null) {
                data.granter = this.granter;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(1, this.amount, (item: Coin) => item.serialize(writer));
            if (this.gas_limit !== undefined)
                writer.writeUint64(2, this.gas_limit);
            if (typeof this.payer === "string" && this.payer.length)
                writer.writeString(3, this.payer);
            if (typeof this.granter === "string" && this.granter.length)
                writer.writeString(4, this.granter);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Fee {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Fee();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Coin.deserialize(reader), Coin));
                        break;
                    case 2:
                        message.gas_limit = reader.readUint64();
                        break;
                    case 3:
                        message.payer = reader.readString();
                        break;
                    case 4:
                        message.granter = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Fee {
            return Fee.deserialize(bytes);
        }
    }
    export class Tip extends pb_1.Message {
        constructor(data?: any[] | {
            amount?: Coin[];
            tipper?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("tipper" in data && data.tipper != undefined) {
                    this.tipper = data.tipper;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 1) as Coin[];
        }
        set amount(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get tipper() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set tipper(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof Coin.prototype.toObject>[];
            tipper?: string;
        }) {
            const message = new Tip({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => Coin.fromObject(item));
            }
            if (data.tipper != null) {
                message.tipper = data.tipper;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof Coin.prototype.toObject>[];
                tipper?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: Coin) => item.toObject());
            }
            if (this.tipper != null) {
                data.tipper = this.tipper;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(1, this.amount, (item: Coin) => item.serialize(writer));
            if (typeof this.tipper === "string" && this.tipper.length)
                writer.writeString(2, this.tipper);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tip {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tip();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Coin.deserialize(reader), Coin));
                        break;
                    case 2:
                        message.tipper = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Tip {
            return Tip.deserialize(bytes);
        }
    }
    export class Coin extends pb_1.Message {
        constructor(data?: any[] | {
            denom?: string;
            amount?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("denom" in data && data.denom != undefined) {
                    this.denom = data.denom;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get denom() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set denom(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get amount() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set amount(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            denom?: string;
            amount?: string;
        }) {
            const message = new Coin({});
            if (data.denom != null) {
                message.denom = data.denom;
            }
            if (data.amount != null) {
                message.amount = data.amount;
            }
            return message;
        }
        toObject() {
            const data: {
                denom?: string;
                amount?: string;
            } = {};
            if (this.denom != null) {
                data.denom = this.denom;
            }
            if (this.amount != null) {
                data.amount = this.amount;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.denom === "string" && this.denom.length)
                writer.writeString(1, this.denom);
            if (typeof this.amount === "string" && this.amount.length)
                writer.writeString(2, this.amount);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Coin {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Coin();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.denom = reader.readString();
                        break;
                    case 2:
                        message.amount = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Coin {
            return Coin.deserialize(bytes);
        }
    }
    export class Any extends pb_1.Message {
        constructor(data?: any[] | {
            type_url?: string;
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type_url" in data && data.type_url != undefined) {
                    this.type_url = data.type_url;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get type_url() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set type_url(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            type_url?: string;
            value?: Uint8Array;
        }) {
            const message = new Any({});
            if (data.type_url != null) {
                message.type_url = data.type_url;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                type_url?: string;
                value?: Uint8Array;
            } = {};
            if (this.type_url != null) {
                data.type_url = this.type_url;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.type_url === "string" && this.type_url.length)
                writer.writeString(1, this.type_url);
            if (this.value !== undefined)
                writer.writeBytes(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Any {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Any();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type_url = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Any {
            return Any.deserialize(bytes);
        }
    }
    export class PubKey extends pb_1.Message {
        constructor(data?: any[] | {
            key?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key" in data && data.key != undefined) {
                    this.key = data.key;
                }
            }
        }
        get key() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set key(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            key?: Uint8Array;
        }) {
            const message = new PubKey({});
            if (data.key != null) {
                message.key = data.key;
            }
            return message;
        }
        toObject() {
            const data: {
                key?: Uint8Array;
            } = {};
            if (this.key != null) {
                data.key = this.key;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key !== undefined)
                writer.writeBytes(1, this.key);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PubKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PubKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PubKey {
            return PubKey.deserialize(bytes);
        }
    }
    export class MsgSend extends pb_1.Message {
        constructor(data?: any[] | {
            from_address?: string;
            to_address?: string;
            amount?: Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("from_address" in data && data.from_address != undefined) {
                    this.from_address = data.from_address;
                }
                if ("to_address" in data && data.to_address != undefined) {
                    this.to_address = data.to_address;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get from_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set from_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get to_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set to_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 3) as Coin[];
        }
        set amount(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            from_address?: string;
            to_address?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>[];
        }) {
            const message = new MsgSend({});
            if (data.from_address != null) {
                message.from_address = data.from_address;
            }
            if (data.to_address != null) {
                message.to_address = data.to_address;
            }
            if (data.amount != null) {
                message.amount = data.amount.map(item => Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                from_address?: string;
                to_address?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>[];
            } = {};
            if (this.from_address != null) {
                data.from_address = this.from_address;
            }
            if (this.to_address != null) {
                data.to_address = this.to_address;
            }
            if (this.amount != null) {
                data.amount = this.amount.map((item: Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.from_address === "string" && this.from_address.length)
                writer.writeString(1, this.from_address);
            if (typeof this.to_address === "string" && this.to_address.length)
                writer.writeString(2, this.to_address);
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(3, this.amount, (item: Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSend {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSend();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.from_address = reader.readString();
                        break;
                    case 2:
                        message.to_address = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Coin.deserialize(reader), Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSend {
            return MsgSend.deserialize(bytes);
        }
    }
    export class MsgMultiSend extends pb_1.Message {
        constructor(data?: any[] | {
            inputs?: Input[];
            outputs?: Output[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("inputs" in data && data.inputs != undefined) {
                    this.inputs = data.inputs;
                }
                if ("outputs" in data && data.outputs != undefined) {
                    this.outputs = data.outputs;
                }
            }
        }
        get inputs() {
            return pb_1.Message.getRepeatedWrapperField(this, Input, 1) as Input[];
        }
        set inputs(value: Input[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get outputs() {
            return pb_1.Message.getRepeatedWrapperField(this, Output, 2) as Output[];
        }
        set outputs(value: Output[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            inputs?: ReturnType<typeof Input.prototype.toObject>[];
            outputs?: ReturnType<typeof Output.prototype.toObject>[];
        }) {
            const message = new MsgMultiSend({});
            if (data.inputs != null) {
                message.inputs = data.inputs.map(item => Input.fromObject(item));
            }
            if (data.outputs != null) {
                message.outputs = data.outputs.map(item => Output.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                inputs?: ReturnType<typeof Input.prototype.toObject>[];
                outputs?: ReturnType<typeof Output.prototype.toObject>[];
            } = {};
            if (this.inputs != null) {
                data.inputs = this.inputs.map((item: Input) => item.toObject());
            }
            if (this.outputs != null) {
                data.outputs = this.outputs.map((item: Output) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.inputs !== undefined)
                writer.writeRepeatedMessage(1, this.inputs, (item: Input) => item.serialize(writer));
            if (this.outputs !== undefined)
                writer.writeRepeatedMessage(2, this.outputs, (item: Output) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgMultiSend {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgMultiSend();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.inputs, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Input.deserialize(reader), Input));
                        break;
                    case 2:
                        reader.readMessage(message.outputs, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Output.deserialize(reader), Output));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgMultiSend {
            return MsgMultiSend.deserialize(bytes);
        }
    }
    export class MsgVerifyInvariant extends pb_1.Message {
        constructor(data?: any[] | {
            sender?: string;
            invariant_module_name?: string;
            invariant_route?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("invariant_module_name" in data && data.invariant_module_name != undefined) {
                    this.invariant_module_name = data.invariant_module_name;
                }
                if ("invariant_route" in data && data.invariant_route != undefined) {
                    this.invariant_route = data.invariant_route;
                }
            }
        }
        get sender() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get invariant_module_name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set invariant_module_name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get invariant_route() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set invariant_route(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            sender?: string;
            invariant_module_name?: string;
            invariant_route?: string;
        }) {
            const message = new MsgVerifyInvariant({});
            if (data.sender != null) {
                message.sender = data.sender;
            }
            if (data.invariant_module_name != null) {
                message.invariant_module_name = data.invariant_module_name;
            }
            if (data.invariant_route != null) {
                message.invariant_route = data.invariant_route;
            }
            return message;
        }
        toObject() {
            const data: {
                sender?: string;
                invariant_module_name?: string;
                invariant_route?: string;
            } = {};
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.invariant_module_name != null) {
                data.invariant_module_name = this.invariant_module_name;
            }
            if (this.invariant_route != null) {
                data.invariant_route = this.invariant_route;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.sender === "string" && this.sender.length)
                writer.writeString(1, this.sender);
            if (typeof this.invariant_module_name === "string" && this.invariant_module_name.length)
                writer.writeString(2, this.invariant_module_name);
            if (typeof this.invariant_route === "string" && this.invariant_route.length)
                writer.writeString(3, this.invariant_route);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgVerifyInvariant {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgVerifyInvariant();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sender = reader.readString();
                        break;
                    case 2:
                        message.invariant_module_name = reader.readString();
                        break;
                    case 3:
                        message.invariant_route = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgVerifyInvariant {
            return MsgVerifyInvariant.deserialize(bytes);
        }
    }
    export class MsgSetWithdrawAddress extends pb_1.Message {
        constructor(data?: any[] | {
            delegator_address?: string;
            withdraw_address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("withdraw_address" in data && data.withdraw_address != undefined) {
                    this.withdraw_address = data.withdraw_address;
                }
            }
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get withdraw_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set withdraw_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            delegator_address?: string;
            withdraw_address?: string;
        }) {
            const message = new MsgSetWithdrawAddress({});
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.withdraw_address != null) {
                message.withdraw_address = data.withdraw_address;
            }
            return message;
        }
        toObject() {
            const data: {
                delegator_address?: string;
                withdraw_address?: string;
            } = {};
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.withdraw_address != null) {
                data.withdraw_address = this.withdraw_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(1, this.delegator_address);
            if (typeof this.withdraw_address === "string" && this.withdraw_address.length)
                writer.writeString(2, this.withdraw_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSetWithdrawAddress {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSetWithdrawAddress();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.delegator_address = reader.readString();
                        break;
                    case 2:
                        message.withdraw_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSetWithdrawAddress {
            return MsgSetWithdrawAddress.deserialize(bytes);
        }
    }
    export class MsgWithdrawDelegatorReward extends pb_1.Message {
        constructor(data?: any[] | {
            delegator_address?: string;
            validator_address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
            }
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            delegator_address?: string;
            validator_address?: string;
        }) {
            const message = new MsgWithdrawDelegatorReward({});
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            return message;
        }
        toObject() {
            const data: {
                delegator_address?: string;
                validator_address?: string;
            } = {};
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(1, this.delegator_address);
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(2, this.validator_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgWithdrawDelegatorReward {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgWithdrawDelegatorReward();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.delegator_address = reader.readString();
                        break;
                    case 2:
                        message.validator_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgWithdrawDelegatorReward {
            return MsgWithdrawDelegatorReward.deserialize(bytes);
        }
    }
    export class MsgWithdrawValidatorCommission extends pb_1.Message {
        constructor(data?: any[] | {
            validator_address?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
            }
        }
        get validator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            validator_address?: string;
        }) {
            const message = new MsgWithdrawValidatorCommission({});
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            return message;
        }
        toObject() {
            const data: {
                validator_address?: string;
            } = {};
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(1, this.validator_address);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgWithdrawValidatorCommission {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgWithdrawValidatorCommission();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.validator_address = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgWithdrawValidatorCommission {
            return MsgWithdrawValidatorCommission.deserialize(bytes);
        }
    }
    export class MsgFundCommunityPool extends pb_1.Message {
        constructor(data?: any[] | {
            amount?: Coin[];
            depositor?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("depositor" in data && data.depositor != undefined) {
                    this.depositor = data.depositor;
                }
            }
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 1) as Coin[];
        }
        set amount(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get depositor() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set depositor(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            amount?: ReturnType<typeof Coin.prototype.toObject>[];
            depositor?: string;
        }) {
            const message = new MsgFundCommunityPool({});
            if (data.amount != null) {
                message.amount = data.amount.map(item => Coin.fromObject(item));
            }
            if (data.depositor != null) {
                message.depositor = data.depositor;
            }
            return message;
        }
        toObject() {
            const data: {
                amount?: ReturnType<typeof Coin.prototype.toObject>[];
                depositor?: string;
            } = {};
            if (this.amount != null) {
                data.amount = this.amount.map((item: Coin) => item.toObject());
            }
            if (this.depositor != null) {
                data.depositor = this.depositor;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(1, this.amount, (item: Coin) => item.serialize(writer));
            if (typeof this.depositor === "string" && this.depositor.length)
                writer.writeString(2, this.depositor);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgFundCommunityPool {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgFundCommunityPool();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Coin.deserialize(reader), Coin));
                        break;
                    case 2:
                        message.depositor = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgFundCommunityPool {
            return MsgFundCommunityPool.deserialize(bytes);
        }
    }
    export class MsgSubmitEvidence extends pb_1.Message {
        constructor(data?: any[] | {
            submitter?: string;
            evidence?: Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("submitter" in data && data.submitter != undefined) {
                    this.submitter = data.submitter;
                }
                if ("evidence" in data && data.evidence != undefined) {
                    this.evidence = data.evidence;
                }
            }
        }
        get submitter() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set submitter(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get evidence() {
            return pb_1.Message.getWrapperField(this, Any, 2) as Any;
        }
        set evidence(value: Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        static fromObject(data: {
            submitter?: string;
            evidence?: ReturnType<typeof Any.prototype.toObject>;
        }) {
            const message = new MsgSubmitEvidence({});
            if (data.submitter != null) {
                message.submitter = data.submitter;
            }
            if (data.evidence != null) {
                message.evidence = Any.fromObject(data.evidence);
            }
            return message;
        }
        toObject() {
            const data: {
                submitter?: string;
                evidence?: ReturnType<typeof Any.prototype.toObject>;
            } = {};
            if (this.submitter != null) {
                data.submitter = this.submitter;
            }
            if (this.evidence != null) {
                data.evidence = this.evidence.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.submitter === "string" && this.submitter.length)
                writer.writeString(1, this.submitter);
            if (this.evidence !== undefined)
                writer.writeMessage(2, this.evidence, () => this.evidence.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSubmitEvidence {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSubmitEvidence();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.submitter = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.evidence, () => message.evidence = Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSubmitEvidence {
            return MsgSubmitEvidence.deserialize(bytes);
        }
    }
    export class MsgSubmitProposal extends pb_1.Message {
        constructor(data?: any[] | {
            content?: Any;
            initial_deposit?: Coin[];
            proposer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("content" in data && data.content != undefined) {
                    this.content = data.content;
                }
                if ("initial_deposit" in data && data.initial_deposit != undefined) {
                    this.initial_deposit = data.initial_deposit;
                }
                if ("proposer" in data && data.proposer != undefined) {
                    this.proposer = data.proposer;
                }
            }
        }
        get content() {
            return pb_1.Message.getWrapperField(this, Any, 1) as Any;
        }
        set content(value: Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get initial_deposit() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 2) as Coin[];
        }
        set initial_deposit(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get proposer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set proposer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            content?: ReturnType<typeof Any.prototype.toObject>;
            initial_deposit?: ReturnType<typeof Coin.prototype.toObject>[];
            proposer?: string;
        }) {
            const message = new MsgSubmitProposal({});
            if (data.content != null) {
                message.content = Any.fromObject(data.content);
            }
            if (data.initial_deposit != null) {
                message.initial_deposit = data.initial_deposit.map(item => Coin.fromObject(item));
            }
            if (data.proposer != null) {
                message.proposer = data.proposer;
            }
            return message;
        }
        toObject() {
            const data: {
                content?: ReturnType<typeof Any.prototype.toObject>;
                initial_deposit?: ReturnType<typeof Coin.prototype.toObject>[];
                proposer?: string;
            } = {};
            if (this.content != null) {
                data.content = this.content.toObject();
            }
            if (this.initial_deposit != null) {
                data.initial_deposit = this.initial_deposit.map((item: Coin) => item.toObject());
            }
            if (this.proposer != null) {
                data.proposer = this.proposer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.content !== undefined)
                writer.writeMessage(1, this.content, () => this.content.serialize(writer));
            if (this.initial_deposit !== undefined)
                writer.writeRepeatedMessage(2, this.initial_deposit, (item: Coin) => item.serialize(writer));
            if (typeof this.proposer === "string" && this.proposer.length)
                writer.writeString(3, this.proposer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSubmitProposal {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSubmitProposal();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.content, () => message.content = Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.initial_deposit, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Coin.deserialize(reader), Coin));
                        break;
                    case 3:
                        message.proposer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSubmitProposal {
            return MsgSubmitProposal.deserialize(bytes);
        }
    }
    export class MsgVote extends pb_1.Message {
        constructor(data?: any[] | {
            proposal_id?: number;
            voter?: string;
            option?: VoteOption;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("proposal_id" in data && data.proposal_id != undefined) {
                    this.proposal_id = data.proposal_id;
                }
                if ("voter" in data && data.voter != undefined) {
                    this.voter = data.voter;
                }
                if ("option" in data && data.option != undefined) {
                    this.option = data.option;
                }
            }
        }
        get proposal_id() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set proposal_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get voter() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set voter(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get option() {
            return pb_1.Message.getField(this, 3) as VoteOption;
        }
        set option(value: VoteOption) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            proposal_id?: number;
            voter?: string;
            option?: VoteOption;
        }) {
            const message = new MsgVote({});
            if (data.proposal_id != null) {
                message.proposal_id = data.proposal_id;
            }
            if (data.voter != null) {
                message.voter = data.voter;
            }
            if (data.option != null) {
                message.option = data.option;
            }
            return message;
        }
        toObject() {
            const data: {
                proposal_id?: number;
                voter?: string;
                option?: VoteOption;
            } = {};
            if (this.proposal_id != null) {
                data.proposal_id = this.proposal_id;
            }
            if (this.voter != null) {
                data.voter = this.voter;
            }
            if (this.option != null) {
                data.option = this.option;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.proposal_id !== undefined)
                writer.writeUint64(1, this.proposal_id);
            if (typeof this.voter === "string" && this.voter.length)
                writer.writeString(2, this.voter);
            if (this.option !== undefined)
                writer.writeEnum(3, this.option);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgVote {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgVote();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.proposal_id = reader.readUint64();
                        break;
                    case 2:
                        message.voter = reader.readString();
                        break;
                    case 3:
                        message.option = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgVote {
            return MsgVote.deserialize(bytes);
        }
    }
    export class MsgDeposit extends pb_1.Message {
        constructor(data?: any[] | {
            proposal_id?: number;
            depositor?: string;
            amount?: Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("proposal_id" in data && data.proposal_id != undefined) {
                    this.proposal_id = data.proposal_id;
                }
                if ("depositor" in data && data.depositor != undefined) {
                    this.depositor = data.depositor;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get proposal_id() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set proposal_id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get depositor() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set depositor(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 3) as Coin[];
        }
        set amount(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            proposal_id?: number;
            depositor?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>[];
        }) {
            const message = new MsgDeposit({});
            if (data.proposal_id != null) {
                message.proposal_id = data.proposal_id;
            }
            if (data.depositor != null) {
                message.depositor = data.depositor;
            }
            if (data.amount != null) {
                message.amount = data.amount.map(item => Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                proposal_id?: number;
                depositor?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>[];
            } = {};
            if (this.proposal_id != null) {
                data.proposal_id = this.proposal_id;
            }
            if (this.depositor != null) {
                data.depositor = this.depositor;
            }
            if (this.amount != null) {
                data.amount = this.amount.map((item: Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.proposal_id !== undefined)
                writer.writeUint64(1, this.proposal_id);
            if (typeof this.depositor === "string" && this.depositor.length)
                writer.writeString(2, this.depositor);
            if (this.amount !== undefined)
                writer.writeRepeatedMessage(3, this.amount, (item: Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgDeposit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgDeposit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.proposal_id = reader.readUint64();
                        break;
                    case 2:
                        message.depositor = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Coin.deserialize(reader), Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgDeposit {
            return MsgDeposit.deserialize(bytes);
        }
    }
    export class MsgUnjail extends pb_1.Message {
        constructor(data?: any[] | {
            validator_addr?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("validator_addr" in data && data.validator_addr != undefined) {
                    this.validator_addr = data.validator_addr;
                }
            }
        }
        get validator_addr() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set validator_addr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            validator_addr?: string;
        }) {
            const message = new MsgUnjail({});
            if (data.validator_addr != null) {
                message.validator_addr = data.validator_addr;
            }
            return message;
        }
        toObject() {
            const data: {
                validator_addr?: string;
            } = {};
            if (this.validator_addr != null) {
                data.validator_addr = this.validator_addr;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.validator_addr === "string" && this.validator_addr.length)
                writer.writeString(1, this.validator_addr);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUnjail {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUnjail();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.validator_addr = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUnjail {
            return MsgUnjail.deserialize(bytes);
        }
    }
    export class MsgCreateValidator extends pb_1.Message {
        constructor(data?: any[] | {
            description?: Description;
            commission?: CommissionRates;
            min_self_delegation?: string;
            delegator_address?: string;
            validator_address?: string;
            pubkey?: Any;
            value?: Coin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("commission" in data && data.commission != undefined) {
                    this.commission = data.commission;
                }
                if ("min_self_delegation" in data && data.min_self_delegation != undefined) {
                    this.min_self_delegation = data.min_self_delegation;
                }
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("pubkey" in data && data.pubkey != undefined) {
                    this.pubkey = data.pubkey;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get description() {
            return pb_1.Message.getWrapperField(this, Description, 1) as Description;
        }
        set description(value: Description) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get commission() {
            return pb_1.Message.getWrapperField(this, CommissionRates, 2) as CommissionRates;
        }
        set commission(value: CommissionRates) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get min_self_delegation() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set min_self_delegation(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get pubkey() {
            return pb_1.Message.getWrapperField(this, Any, 6) as Any;
        }
        set pubkey(value: Any) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get value() {
            return pb_1.Message.getWrapperField(this, Coin, 7) as Coin;
        }
        set value(value: Coin) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        static fromObject(data: {
            description?: ReturnType<typeof Description.prototype.toObject>;
            commission?: ReturnType<typeof CommissionRates.prototype.toObject>;
            min_self_delegation?: string;
            delegator_address?: string;
            validator_address?: string;
            pubkey?: ReturnType<typeof Any.prototype.toObject>;
            value?: ReturnType<typeof Coin.prototype.toObject>;
        }) {
            const message = new MsgCreateValidator({});
            if (data.description != null) {
                message.description = Description.fromObject(data.description);
            }
            if (data.commission != null) {
                message.commission = CommissionRates.fromObject(data.commission);
            }
            if (data.min_self_delegation != null) {
                message.min_self_delegation = data.min_self_delegation;
            }
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.pubkey != null) {
                message.pubkey = Any.fromObject(data.pubkey);
            }
            if (data.value != null) {
                message.value = Coin.fromObject(data.value);
            }
            return message;
        }
        toObject() {
            const data: {
                description?: ReturnType<typeof Description.prototype.toObject>;
                commission?: ReturnType<typeof CommissionRates.prototype.toObject>;
                min_self_delegation?: string;
                delegator_address?: string;
                validator_address?: string;
                pubkey?: ReturnType<typeof Any.prototype.toObject>;
                value?: ReturnType<typeof Coin.prototype.toObject>;
            } = {};
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            if (this.commission != null) {
                data.commission = this.commission.toObject();
            }
            if (this.min_self_delegation != null) {
                data.min_self_delegation = this.min_self_delegation;
            }
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.pubkey != null) {
                data.pubkey = this.pubkey.toObject();
            }
            if (this.value != null) {
                data.value = this.value.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.description !== undefined)
                writer.writeMessage(1, this.description, () => this.description.serialize(writer));
            if (this.commission !== undefined)
                writer.writeMessage(2, this.commission, () => this.commission.serialize(writer));
            if (typeof this.min_self_delegation === "string" && this.min_self_delegation.length)
                writer.writeString(3, this.min_self_delegation);
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(4, this.delegator_address);
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(5, this.validator_address);
            if (this.pubkey !== undefined)
                writer.writeMessage(6, this.pubkey, () => this.pubkey.serialize(writer));
            if (this.value !== undefined)
                writer.writeMessage(7, this.value, () => this.value.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCreateValidator {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCreateValidator();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.description, () => message.description = Description.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.commission, () => message.commission = CommissionRates.deserialize(reader));
                        break;
                    case 3:
                        message.min_self_delegation = reader.readString();
                        break;
                    case 4:
                        message.delegator_address = reader.readString();
                        break;
                    case 5:
                        message.validator_address = reader.readString();
                        break;
                    case 6:
                        reader.readMessage(message.pubkey, () => message.pubkey = Any.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.value, () => message.value = Coin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCreateValidator {
            return MsgCreateValidator.deserialize(bytes);
        }
    }
    export class MsgEditValidator extends pb_1.Message {
        constructor(data?: any[] | {
            description?: Description;
            validator_address?: string;
            commission_rate?: string;
            min_self_delegation?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("description" in data && data.description != undefined) {
                    this.description = data.description;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("commission_rate" in data && data.commission_rate != undefined) {
                    this.commission_rate = data.commission_rate;
                }
                if ("min_self_delegation" in data && data.min_self_delegation != undefined) {
                    this.min_self_delegation = data.min_self_delegation;
                }
            }
        }
        get description() {
            return pb_1.Message.getWrapperField(this, Description, 1) as Description;
        }
        set description(value: Description) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get commission_rate() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set commission_rate(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get min_self_delegation() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set min_self_delegation(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            description?: ReturnType<typeof Description.prototype.toObject>;
            validator_address?: string;
            commission_rate?: string;
            min_self_delegation?: string;
        }) {
            const message = new MsgEditValidator({});
            if (data.description != null) {
                message.description = Description.fromObject(data.description);
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.commission_rate != null) {
                message.commission_rate = data.commission_rate;
            }
            if (data.min_self_delegation != null) {
                message.min_self_delegation = data.min_self_delegation;
            }
            return message;
        }
        toObject() {
            const data: {
                description?: ReturnType<typeof Description.prototype.toObject>;
                validator_address?: string;
                commission_rate?: string;
                min_self_delegation?: string;
            } = {};
            if (this.description != null) {
                data.description = this.description.toObject();
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.commission_rate != null) {
                data.commission_rate = this.commission_rate;
            }
            if (this.min_self_delegation != null) {
                data.min_self_delegation = this.min_self_delegation;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.description !== undefined)
                writer.writeMessage(1, this.description, () => this.description.serialize(writer));
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(2, this.validator_address);
            if (typeof this.commission_rate === "string" && this.commission_rate.length)
                writer.writeString(3, this.commission_rate);
            if (typeof this.min_self_delegation === "string" && this.min_self_delegation.length)
                writer.writeString(4, this.min_self_delegation);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgEditValidator {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgEditValidator();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.description, () => message.description = Description.deserialize(reader));
                        break;
                    case 2:
                        message.validator_address = reader.readString();
                        break;
                    case 3:
                        message.commission_rate = reader.readString();
                        break;
                    case 4:
                        message.min_self_delegation = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgEditValidator {
            return MsgEditValidator.deserialize(bytes);
        }
    }
    export class MsgDelegate extends pb_1.Message {
        constructor(data?: any[] | {
            delegator_address?: string;
            validator_address?: string;
            amount?: Coin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Coin, 3) as Coin;
        }
        set amount(value: Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            delegator_address?: string;
            validator_address?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>;
        }) {
            const message = new MsgDelegate({});
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.amount != null) {
                message.amount = Coin.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                delegator_address?: string;
                validator_address?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>;
            } = {};
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(1, this.delegator_address);
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(2, this.validator_address);
            if (this.amount !== undefined)
                writer.writeMessage(3, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgDelegate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgDelegate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.delegator_address = reader.readString();
                        break;
                    case 2:
                        message.validator_address = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => message.amount = Coin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgDelegate {
            return MsgDelegate.deserialize(bytes);
        }
    }
    export class MsgBeginRedelegate extends pb_1.Message {
        constructor(data?: any[] | {
            delegator_address?: string;
            validator_src_address?: string;
            validator_dst_address?: string;
            amount?: Coin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("validator_src_address" in data && data.validator_src_address != undefined) {
                    this.validator_src_address = data.validator_src_address;
                }
                if ("validator_dst_address" in data && data.validator_dst_address != undefined) {
                    this.validator_dst_address = data.validator_dst_address;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get validator_src_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set validator_src_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get validator_dst_address() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set validator_dst_address(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Coin, 4) as Coin;
        }
        set amount(value: Coin) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            delegator_address?: string;
            validator_src_address?: string;
            validator_dst_address?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>;
        }) {
            const message = new MsgBeginRedelegate({});
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.validator_src_address != null) {
                message.validator_src_address = data.validator_src_address;
            }
            if (data.validator_dst_address != null) {
                message.validator_dst_address = data.validator_dst_address;
            }
            if (data.amount != null) {
                message.amount = Coin.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                delegator_address?: string;
                validator_src_address?: string;
                validator_dst_address?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>;
            } = {};
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.validator_src_address != null) {
                data.validator_src_address = this.validator_src_address;
            }
            if (this.validator_dst_address != null) {
                data.validator_dst_address = this.validator_dst_address;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(1, this.delegator_address);
            if (typeof this.validator_src_address === "string" && this.validator_src_address.length)
                writer.writeString(2, this.validator_src_address);
            if (typeof this.validator_dst_address === "string" && this.validator_dst_address.length)
                writer.writeString(3, this.validator_dst_address);
            if (this.amount !== undefined)
                writer.writeMessage(4, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgBeginRedelegate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgBeginRedelegate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.delegator_address = reader.readString();
                        break;
                    case 2:
                        message.validator_src_address = reader.readString();
                        break;
                    case 3:
                        message.validator_dst_address = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.amount, () => message.amount = Coin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgBeginRedelegate {
            return MsgBeginRedelegate.deserialize(bytes);
        }
    }
    export class MsgUndelegate extends pb_1.Message {
        constructor(data?: any[] | {
            delegator_address?: string;
            validator_address?: string;
            amount?: Coin;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("delegator_address" in data && data.delegator_address != undefined) {
                    this.delegator_address = data.delegator_address;
                }
                if ("validator_address" in data && data.validator_address != undefined) {
                    this.validator_address = data.validator_address;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
            }
        }
        get delegator_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set delegator_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get validator_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set validator_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Coin, 3) as Coin;
        }
        set amount(value: Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            delegator_address?: string;
            validator_address?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>;
        }) {
            const message = new MsgUndelegate({});
            if (data.delegator_address != null) {
                message.delegator_address = data.delegator_address;
            }
            if (data.validator_address != null) {
                message.validator_address = data.validator_address;
            }
            if (data.amount != null) {
                message.amount = Coin.fromObject(data.amount);
            }
            return message;
        }
        toObject() {
            const data: {
                delegator_address?: string;
                validator_address?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>;
            } = {};
            if (this.delegator_address != null) {
                data.delegator_address = this.delegator_address;
            }
            if (this.validator_address != null) {
                data.validator_address = this.validator_address;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.delegator_address === "string" && this.delegator_address.length)
                writer.writeString(1, this.delegator_address);
            if (typeof this.validator_address === "string" && this.validator_address.length)
                writer.writeString(2, this.validator_address);
            if (this.amount !== undefined)
                writer.writeMessage(3, this.amount, () => this.amount.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUndelegate {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUndelegate();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.delegator_address = reader.readString();
                        break;
                    case 2:
                        message.validator_address = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => message.amount = Coin.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUndelegate {
            return MsgUndelegate.deserialize(bytes);
        }
    }
    export class MsgCreateVestingAccount extends pb_1.Message {
        constructor(data?: any[] | {
            from_address?: string;
            to_address?: string;
            amount?: Coin;
            end_time?: number;
            delayed?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("from_address" in data && data.from_address != undefined) {
                    this.from_address = data.from_address;
                }
                if ("to_address" in data && data.to_address != undefined) {
                    this.to_address = data.to_address;
                }
                if ("amount" in data && data.amount != undefined) {
                    this.amount = data.amount;
                }
                if ("end_time" in data && data.end_time != undefined) {
                    this.end_time = data.end_time;
                }
                if ("delayed" in data && data.delayed != undefined) {
                    this.delayed = data.delayed;
                }
            }
        }
        get from_address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set from_address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get to_address() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set to_address(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get amount() {
            return pb_1.Message.getWrapperField(this, Coin, 3) as Coin;
        }
        set amount(value: Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get end_time() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set end_time(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get delayed() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set delayed(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            from_address?: string;
            to_address?: string;
            amount?: ReturnType<typeof Coin.prototype.toObject>;
            end_time?: number;
            delayed?: boolean;
        }) {
            const message = new MsgCreateVestingAccount({});
            if (data.from_address != null) {
                message.from_address = data.from_address;
            }
            if (data.to_address != null) {
                message.to_address = data.to_address;
            }
            if (data.amount != null) {
                message.amount = Coin.fromObject(data.amount);
            }
            if (data.end_time != null) {
                message.end_time = data.end_time;
            }
            if (data.delayed != null) {
                message.delayed = data.delayed;
            }
            return message;
        }
        toObject() {
            const data: {
                from_address?: string;
                to_address?: string;
                amount?: ReturnType<typeof Coin.prototype.toObject>;
                end_time?: number;
                delayed?: boolean;
            } = {};
            if (this.from_address != null) {
                data.from_address = this.from_address;
            }
            if (this.to_address != null) {
                data.to_address = this.to_address;
            }
            if (this.amount != null) {
                data.amount = this.amount.toObject();
            }
            if (this.end_time != null) {
                data.end_time = this.end_time;
            }
            if (this.delayed != null) {
                data.delayed = this.delayed;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.from_address === "string" && this.from_address.length)
                writer.writeString(1, this.from_address);
            if (typeof this.to_address === "string" && this.to_address.length)
                writer.writeString(2, this.to_address);
            if (this.amount !== undefined)
                writer.writeMessage(3, this.amount, () => this.amount.serialize(writer));
            if (this.end_time !== undefined)
                writer.writeInt64(4, this.end_time);
            if (this.delayed !== undefined)
                writer.writeBool(5, this.delayed);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCreateVestingAccount {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCreateVestingAccount();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.from_address = reader.readString();
                        break;
                    case 2:
                        message.to_address = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.amount, () => message.amount = Coin.deserialize(reader));
                        break;
                    case 4:
                        message.end_time = reader.readInt64();
                        break;
                    case 5:
                        message.delayed = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCreateVestingAccount {
            return MsgCreateVestingAccount.deserialize(bytes);
        }
    }
    export class MsgTransfer extends pb_1.Message {
        constructor(data?: any[] | {
            source_port?: string;
            source_channel?: string;
            token?: Coin;
            sender?: string;
            receiver?: string;
            timeout_height?: Height;
            timeout_timestamp?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("source_port" in data && data.source_port != undefined) {
                    this.source_port = data.source_port;
                }
                if ("source_channel" in data && data.source_channel != undefined) {
                    this.source_channel = data.source_channel;
                }
                if ("token" in data && data.token != undefined) {
                    this.token = data.token;
                }
                if ("sender" in data && data.sender != undefined) {
                    this.sender = data.sender;
                }
                if ("receiver" in data && data.receiver != undefined) {
                    this.receiver = data.receiver;
                }
                if ("timeout_height" in data && data.timeout_height != undefined) {
                    this.timeout_height = data.timeout_height;
                }
                if ("timeout_timestamp" in data && data.timeout_timestamp != undefined) {
                    this.timeout_timestamp = data.timeout_timestamp;
                }
            }
        }
        get source_port() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set source_port(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get source_channel() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set source_channel(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get token() {
            return pb_1.Message.getWrapperField(this, Coin, 3) as Coin;
        }
        set token(value: Coin) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get sender() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get receiver() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set receiver(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get timeout_height() {
            return pb_1.Message.getWrapperField(this, Height, 6) as Height;
        }
        set timeout_height(value: Height) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get timeout_timestamp() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set timeout_timestamp(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            source_port?: string;
            source_channel?: string;
            token?: ReturnType<typeof Coin.prototype.toObject>;
            sender?: string;
            receiver?: string;
            timeout_height?: ReturnType<typeof Height.prototype.toObject>;
            timeout_timestamp?: number;
        }) {
            const message = new MsgTransfer({});
            if (data.source_port != null) {
                message.source_port = data.source_port;
            }
            if (data.source_channel != null) {
                message.source_channel = data.source_channel;
            }
            if (data.token != null) {
                message.token = Coin.fromObject(data.token);
            }
            if (data.sender != null) {
                message.sender = data.sender;
            }
            if (data.receiver != null) {
                message.receiver = data.receiver;
            }
            if (data.timeout_height != null) {
                message.timeout_height = Height.fromObject(data.timeout_height);
            }
            if (data.timeout_timestamp != null) {
                message.timeout_timestamp = data.timeout_timestamp;
            }
            return message;
        }
        toObject() {
            const data: {
                source_port?: string;
                source_channel?: string;
                token?: ReturnType<typeof Coin.prototype.toObject>;
                sender?: string;
                receiver?: string;
                timeout_height?: ReturnType<typeof Height.prototype.toObject>;
                timeout_timestamp?: number;
            } = {};
            if (this.source_port != null) {
                data.source_port = this.source_port;
            }
            if (this.source_channel != null) {
                data.source_channel = this.source_channel;
            }
            if (this.token != null) {
                data.token = this.token.toObject();
            }
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.receiver != null) {
                data.receiver = this.receiver;
            }
            if (this.timeout_height != null) {
                data.timeout_height = this.timeout_height.toObject();
            }
            if (this.timeout_timestamp != null) {
                data.timeout_timestamp = this.timeout_timestamp;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.source_port === "string" && this.source_port.length)
                writer.writeString(1, this.source_port);
            if (typeof this.source_channel === "string" && this.source_channel.length)
                writer.writeString(2, this.source_channel);
            if (this.token !== undefined)
                writer.writeMessage(3, this.token, () => this.token.serialize(writer));
            if (typeof this.sender === "string" && this.sender.length)
                writer.writeString(4, this.sender);
            if (typeof this.receiver === "string" && this.receiver.length)
                writer.writeString(5, this.receiver);
            if (this.timeout_height !== undefined)
                writer.writeMessage(6, this.timeout_height, () => this.timeout_height.serialize(writer));
            if (this.timeout_timestamp !== undefined)
                writer.writeUint64(7, this.timeout_timestamp);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgTransfer {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgTransfer();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.source_port = reader.readString();
                        break;
                    case 2:
                        message.source_channel = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.token, () => message.token = Coin.deserialize(reader));
                        break;
                    case 4:
                        message.sender = reader.readString();
                        break;
                    case 5:
                        message.receiver = reader.readString();
                        break;
                    case 6:
                        reader.readMessage(message.timeout_height, () => message.timeout_height = Height.deserialize(reader));
                        break;
                    case 7:
                        message.timeout_timestamp = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgTransfer {
            return MsgTransfer.deserialize(bytes);
        }
    }
    export class MsgChannelOpenInit extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel?: Channel;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel" in data && data.channel != undefined) {
                    this.channel = data.channel;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel() {
            return pb_1.Message.getWrapperField(this, Channel, 2) as Channel;
        }
        set channel(value: Channel) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel?: ReturnType<typeof Channel.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgChannelOpenInit({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel != null) {
                message.channel = Channel.fromObject(data.channel);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel?: ReturnType<typeof Channel.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel != null) {
                data.channel = this.channel.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (this.channel !== undefined)
                writer.writeMessage(2, this.channel, () => this.channel.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(3, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelOpenInit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelOpenInit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.channel, () => message.channel = Channel.deserialize(reader));
                        break;
                    case 3:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelOpenInit {
            return MsgChannelOpenInit.deserialize(bytes);
        }
    }
    export class MsgChannelOpenTry extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            previous_channel_id?: string;
            channel?: Channel;
            counterparty_version?: string;
            proof_init?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("previous_channel_id" in data && data.previous_channel_id != undefined) {
                    this.previous_channel_id = data.previous_channel_id;
                }
                if ("channel" in data && data.channel != undefined) {
                    this.channel = data.channel;
                }
                if ("counterparty_version" in data && data.counterparty_version != undefined) {
                    this.counterparty_version = data.counterparty_version;
                }
                if ("proof_init" in data && data.proof_init != undefined) {
                    this.proof_init = data.proof_init;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get previous_channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set previous_channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get channel() {
            return pb_1.Message.getWrapperField(this, Channel, 3) as Channel;
        }
        set channel(value: Channel) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get counterparty_version() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set counterparty_version(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get proof_init() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set proof_init(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 6) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            port_id?: string;
            previous_channel_id?: string;
            channel?: ReturnType<typeof Channel.prototype.toObject>;
            counterparty_version?: string;
            proof_init?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgChannelOpenTry({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.previous_channel_id != null) {
                message.previous_channel_id = data.previous_channel_id;
            }
            if (data.channel != null) {
                message.channel = Channel.fromObject(data.channel);
            }
            if (data.counterparty_version != null) {
                message.counterparty_version = data.counterparty_version;
            }
            if (data.proof_init != null) {
                message.proof_init = data.proof_init;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                previous_channel_id?: string;
                channel?: ReturnType<typeof Channel.prototype.toObject>;
                counterparty_version?: string;
                proof_init?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.previous_channel_id != null) {
                data.previous_channel_id = this.previous_channel_id;
            }
            if (this.channel != null) {
                data.channel = this.channel.toObject();
            }
            if (this.counterparty_version != null) {
                data.counterparty_version = this.counterparty_version;
            }
            if (this.proof_init != null) {
                data.proof_init = this.proof_init;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.previous_channel_id === "string" && this.previous_channel_id.length)
                writer.writeString(2, this.previous_channel_id);
            if (this.channel !== undefined)
                writer.writeMessage(3, this.channel, () => this.channel.serialize(writer));
            if (typeof this.counterparty_version === "string" && this.counterparty_version.length)
                writer.writeString(4, this.counterparty_version);
            if (this.proof_init !== undefined)
                writer.writeBytes(5, this.proof_init);
            if (this.proof_height !== undefined)
                writer.writeMessage(6, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(7, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelOpenTry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelOpenTry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.previous_channel_id = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.channel, () => message.channel = Channel.deserialize(reader));
                        break;
                    case 4:
                        message.counterparty_version = reader.readString();
                        break;
                    case 5:
                        message.proof_init = reader.readBytes();
                        break;
                    case 6:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 7:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelOpenTry {
            return MsgChannelOpenTry.deserialize(bytes);
        }
    }
    export class MsgChannelOpenAck extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel_id?: string;
            counterparty_channel_id?: string;
            counterparty_version?: string;
            proof_try?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel_id" in data && data.channel_id != undefined) {
                    this.channel_id = data.channel_id;
                }
                if ("counterparty_channel_id" in data && data.counterparty_channel_id != undefined) {
                    this.counterparty_channel_id = data.counterparty_channel_id;
                }
                if ("counterparty_version" in data && data.counterparty_version != undefined) {
                    this.counterparty_version = data.counterparty_version;
                }
                if ("proof_try" in data && data.proof_try != undefined) {
                    this.proof_try = data.proof_try;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get counterparty_channel_id() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set counterparty_channel_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get counterparty_version() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set counterparty_version(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get proof_try() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set proof_try(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 6) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel_id?: string;
            counterparty_channel_id?: string;
            counterparty_version?: string;
            proof_try?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgChannelOpenAck({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel_id != null) {
                message.channel_id = data.channel_id;
            }
            if (data.counterparty_channel_id != null) {
                message.counterparty_channel_id = data.counterparty_channel_id;
            }
            if (data.counterparty_version != null) {
                message.counterparty_version = data.counterparty_version;
            }
            if (data.proof_try != null) {
                message.proof_try = data.proof_try;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel_id?: string;
                counterparty_channel_id?: string;
                counterparty_version?: string;
                proof_try?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel_id != null) {
                data.channel_id = this.channel_id;
            }
            if (this.counterparty_channel_id != null) {
                data.counterparty_channel_id = this.counterparty_channel_id;
            }
            if (this.counterparty_version != null) {
                data.counterparty_version = this.counterparty_version;
            }
            if (this.proof_try != null) {
                data.proof_try = this.proof_try;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.channel_id === "string" && this.channel_id.length)
                writer.writeString(2, this.channel_id);
            if (typeof this.counterparty_channel_id === "string" && this.counterparty_channel_id.length)
                writer.writeString(3, this.counterparty_channel_id);
            if (typeof this.counterparty_version === "string" && this.counterparty_version.length)
                writer.writeString(4, this.counterparty_version);
            if (this.proof_try !== undefined)
                writer.writeBytes(5, this.proof_try);
            if (this.proof_height !== undefined)
                writer.writeMessage(6, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(7, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelOpenAck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelOpenAck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.channel_id = reader.readString();
                        break;
                    case 3:
                        message.counterparty_channel_id = reader.readString();
                        break;
                    case 4:
                        message.counterparty_version = reader.readString();
                        break;
                    case 5:
                        message.proof_try = reader.readBytes();
                        break;
                    case 6:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 7:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelOpenAck {
            return MsgChannelOpenAck.deserialize(bytes);
        }
    }
    export class MsgChannelOpenConfirm extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel_id?: string;
            proof_ack?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel_id" in data && data.channel_id != undefined) {
                    this.channel_id = data.channel_id;
                }
                if ("proof_ack" in data && data.proof_ack != undefined) {
                    this.proof_ack = data.proof_ack;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_ack() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set proof_ack(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 4) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel_id?: string;
            proof_ack?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgChannelOpenConfirm({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel_id != null) {
                message.channel_id = data.channel_id;
            }
            if (data.proof_ack != null) {
                message.proof_ack = data.proof_ack;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel_id?: string;
                proof_ack?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel_id != null) {
                data.channel_id = this.channel_id;
            }
            if (this.proof_ack != null) {
                data.proof_ack = this.proof_ack;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.channel_id === "string" && this.channel_id.length)
                writer.writeString(2, this.channel_id);
            if (this.proof_ack !== undefined)
                writer.writeBytes(3, this.proof_ack);
            if (this.proof_height !== undefined)
                writer.writeMessage(4, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(5, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelOpenConfirm {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelOpenConfirm();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.channel_id = reader.readString();
                        break;
                    case 3:
                        message.proof_ack = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 5:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelOpenConfirm {
            return MsgChannelOpenConfirm.deserialize(bytes);
        }
    }
    export class MsgChannelCloseInit extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel_id?: string;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel_id" in data && data.channel_id != undefined) {
                    this.channel_id = data.channel_id;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel_id?: string;
            signer?: string;
        }) {
            const message = new MsgChannelCloseInit({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel_id != null) {
                message.channel_id = data.channel_id;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel_id?: string;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel_id != null) {
                data.channel_id = this.channel_id;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.channel_id === "string" && this.channel_id.length)
                writer.writeString(2, this.channel_id);
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(3, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelCloseInit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelCloseInit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.channel_id = reader.readString();
                        break;
                    case 3:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelCloseInit {
            return MsgChannelCloseInit.deserialize(bytes);
        }
    }
    export class MsgChannelCloseConfirm extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel_id?: string;
            proof_init?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel_id" in data && data.channel_id != undefined) {
                    this.channel_id = data.channel_id;
                }
                if ("proof_init" in data && data.proof_init != undefined) {
                    this.proof_init = data.proof_init;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_init() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set proof_init(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 4) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel_id?: string;
            proof_init?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgChannelCloseConfirm({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel_id != null) {
                message.channel_id = data.channel_id;
            }
            if (data.proof_init != null) {
                message.proof_init = data.proof_init;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel_id?: string;
                proof_init?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel_id != null) {
                data.channel_id = this.channel_id;
            }
            if (this.proof_init != null) {
                data.proof_init = this.proof_init;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.channel_id === "string" && this.channel_id.length)
                writer.writeString(2, this.channel_id);
            if (this.proof_init !== undefined)
                writer.writeBytes(3, this.proof_init);
            if (this.proof_height !== undefined)
                writer.writeMessage(4, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(5, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgChannelCloseConfirm {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgChannelCloseConfirm();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.channel_id = reader.readString();
                        break;
                    case 3:
                        message.proof_init = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 5:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgChannelCloseConfirm {
            return MsgChannelCloseConfirm.deserialize(bytes);
        }
    }
    export class MsgRecvPacket extends pb_1.Message {
        constructor(data?: any[] | {
            packet?: Packet;
            proof_commitment?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet" in data && data.packet != undefined) {
                    this.packet = data.packet;
                }
                if ("proof_commitment" in data && data.proof_commitment != undefined) {
                    this.proof_commitment = data.proof_commitment;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get packet() {
            return pb_1.Message.getWrapperField(this, Packet, 1) as Packet;
        }
        set packet(value: Packet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get proof_commitment() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set proof_commitment(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 3) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            packet?: ReturnType<typeof Packet.prototype.toObject>;
            proof_commitment?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgRecvPacket({});
            if (data.packet != null) {
                message.packet = Packet.fromObject(data.packet);
            }
            if (data.proof_commitment != null) {
                message.proof_commitment = data.proof_commitment;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                packet?: ReturnType<typeof Packet.prototype.toObject>;
                proof_commitment?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.packet != null) {
                data.packet = this.packet.toObject();
            }
            if (this.proof_commitment != null) {
                data.proof_commitment = this.proof_commitment;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet !== undefined)
                writer.writeMessage(1, this.packet, () => this.packet.serialize(writer));
            if (this.proof_commitment !== undefined)
                writer.writeBytes(2, this.proof_commitment);
            if (this.proof_height !== undefined)
                writer.writeMessage(3, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(4, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgRecvPacket {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgRecvPacket();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.packet, () => message.packet = Packet.deserialize(reader));
                        break;
                    case 2:
                        message.proof_commitment = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 4:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgRecvPacket {
            return MsgRecvPacket.deserialize(bytes);
        }
    }
    export class MsgTimeout extends pb_1.Message {
        constructor(data?: any[] | {
            packet?: Packet;
            proof_unreceived?: Uint8Array;
            proof_height?: Height;
            next_sequence_recv?: number;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet" in data && data.packet != undefined) {
                    this.packet = data.packet;
                }
                if ("proof_unreceived" in data && data.proof_unreceived != undefined) {
                    this.proof_unreceived = data.proof_unreceived;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("next_sequence_recv" in data && data.next_sequence_recv != undefined) {
                    this.next_sequence_recv = data.next_sequence_recv;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get packet() {
            return pb_1.Message.getWrapperField(this, Packet, 1) as Packet;
        }
        set packet(value: Packet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get proof_unreceived() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set proof_unreceived(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 3) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get next_sequence_recv() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set next_sequence_recv(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            packet?: ReturnType<typeof Packet.prototype.toObject>;
            proof_unreceived?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            next_sequence_recv?: number;
            signer?: string;
        }) {
            const message = new MsgTimeout({});
            if (data.packet != null) {
                message.packet = Packet.fromObject(data.packet);
            }
            if (data.proof_unreceived != null) {
                message.proof_unreceived = data.proof_unreceived;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.next_sequence_recv != null) {
                message.next_sequence_recv = data.next_sequence_recv;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                packet?: ReturnType<typeof Packet.prototype.toObject>;
                proof_unreceived?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                next_sequence_recv?: number;
                signer?: string;
            } = {};
            if (this.packet != null) {
                data.packet = this.packet.toObject();
            }
            if (this.proof_unreceived != null) {
                data.proof_unreceived = this.proof_unreceived;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.next_sequence_recv != null) {
                data.next_sequence_recv = this.next_sequence_recv;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet !== undefined)
                writer.writeMessage(1, this.packet, () => this.packet.serialize(writer));
            if (this.proof_unreceived !== undefined)
                writer.writeBytes(2, this.proof_unreceived);
            if (this.proof_height !== undefined)
                writer.writeMessage(3, this.proof_height, () => this.proof_height.serialize(writer));
            if (this.next_sequence_recv !== undefined)
                writer.writeUint64(4, this.next_sequence_recv);
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(5, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgTimeout {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgTimeout();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.packet, () => message.packet = Packet.deserialize(reader));
                        break;
                    case 2:
                        message.proof_unreceived = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 4:
                        message.next_sequence_recv = reader.readUint64();
                        break;
                    case 5:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgTimeout {
            return MsgTimeout.deserialize(bytes);
        }
    }
    export class MsgTimeoutOnClose extends pb_1.Message {
        constructor(data?: any[] | {
            packet?: Packet;
            proof_unreceived?: Uint8Array;
            proof_close?: Uint8Array;
            proof_height?: Height;
            next_sequence_recv?: number;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet" in data && data.packet != undefined) {
                    this.packet = data.packet;
                }
                if ("proof_unreceived" in data && data.proof_unreceived != undefined) {
                    this.proof_unreceived = data.proof_unreceived;
                }
                if ("proof_close" in data && data.proof_close != undefined) {
                    this.proof_close = data.proof_close;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("next_sequence_recv" in data && data.next_sequence_recv != undefined) {
                    this.next_sequence_recv = data.next_sequence_recv;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get packet() {
            return pb_1.Message.getWrapperField(this, Packet, 1) as Packet;
        }
        set packet(value: Packet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get proof_unreceived() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set proof_unreceived(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_close() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set proof_close(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 4) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get next_sequence_recv() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set next_sequence_recv(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            packet?: ReturnType<typeof Packet.prototype.toObject>;
            proof_unreceived?: Uint8Array;
            proof_close?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            next_sequence_recv?: number;
            signer?: string;
        }) {
            const message = new MsgTimeoutOnClose({});
            if (data.packet != null) {
                message.packet = Packet.fromObject(data.packet);
            }
            if (data.proof_unreceived != null) {
                message.proof_unreceived = data.proof_unreceived;
            }
            if (data.proof_close != null) {
                message.proof_close = data.proof_close;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.next_sequence_recv != null) {
                message.next_sequence_recv = data.next_sequence_recv;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                packet?: ReturnType<typeof Packet.prototype.toObject>;
                proof_unreceived?: Uint8Array;
                proof_close?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                next_sequence_recv?: number;
                signer?: string;
            } = {};
            if (this.packet != null) {
                data.packet = this.packet.toObject();
            }
            if (this.proof_unreceived != null) {
                data.proof_unreceived = this.proof_unreceived;
            }
            if (this.proof_close != null) {
                data.proof_close = this.proof_close;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.next_sequence_recv != null) {
                data.next_sequence_recv = this.next_sequence_recv;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet !== undefined)
                writer.writeMessage(1, this.packet, () => this.packet.serialize(writer));
            if (this.proof_unreceived !== undefined)
                writer.writeBytes(2, this.proof_unreceived);
            if (this.proof_close !== undefined)
                writer.writeBytes(3, this.proof_close);
            if (this.proof_height !== undefined)
                writer.writeMessage(4, this.proof_height, () => this.proof_height.serialize(writer));
            if (this.next_sequence_recv !== undefined)
                writer.writeUint64(5, this.next_sequence_recv);
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(6, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgTimeoutOnClose {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgTimeoutOnClose();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.packet, () => message.packet = Packet.deserialize(reader));
                        break;
                    case 2:
                        message.proof_unreceived = reader.readBytes();
                        break;
                    case 3:
                        message.proof_close = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 5:
                        message.next_sequence_recv = reader.readUint64();
                        break;
                    case 6:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgTimeoutOnClose {
            return MsgTimeoutOnClose.deserialize(bytes);
        }
    }
    export class MsgAcknowledgement extends pb_1.Message {
        constructor(data?: any[] | {
            packet?: Packet;
            acknowledgement?: Uint8Array;
            proof_acked?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("packet" in data && data.packet != undefined) {
                    this.packet = data.packet;
                }
                if ("acknowledgement" in data && data.acknowledgement != undefined) {
                    this.acknowledgement = data.acknowledgement;
                }
                if ("proof_acked" in data && data.proof_acked != undefined) {
                    this.proof_acked = data.proof_acked;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get packet() {
            return pb_1.Message.getWrapperField(this, Packet, 1) as Packet;
        }
        set packet(value: Packet) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get acknowledgement() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set acknowledgement(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_acked() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set proof_acked(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 4) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            packet?: ReturnType<typeof Packet.prototype.toObject>;
            acknowledgement?: Uint8Array;
            proof_acked?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgAcknowledgement({});
            if (data.packet != null) {
                message.packet = Packet.fromObject(data.packet);
            }
            if (data.acknowledgement != null) {
                message.acknowledgement = data.acknowledgement;
            }
            if (data.proof_acked != null) {
                message.proof_acked = data.proof_acked;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                packet?: ReturnType<typeof Packet.prototype.toObject>;
                acknowledgement?: Uint8Array;
                proof_acked?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.packet != null) {
                data.packet = this.packet.toObject();
            }
            if (this.acknowledgement != null) {
                data.acknowledgement = this.acknowledgement;
            }
            if (this.proof_acked != null) {
                data.proof_acked = this.proof_acked;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.packet !== undefined)
                writer.writeMessage(1, this.packet, () => this.packet.serialize(writer));
            if (this.acknowledgement !== undefined)
                writer.writeBytes(2, this.acknowledgement);
            if (this.proof_acked !== undefined)
                writer.writeBytes(3, this.proof_acked);
            if (this.proof_height !== undefined)
                writer.writeMessage(4, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(5, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgAcknowledgement {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgAcknowledgement();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.packet, () => message.packet = Packet.deserialize(reader));
                        break;
                    case 2:
                        message.acknowledgement = reader.readBytes();
                        break;
                    case 3:
                        message.proof_acked = reader.readBytes();
                        break;
                    case 4:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 5:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgAcknowledgement {
            return MsgAcknowledgement.deserialize(bytes);
        }
    }
    export class MsgCreateClient extends pb_1.Message {
        constructor(data?: any[] | {
            client_state?: Any;
            consensus_state?: Any;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_state" in data && data.client_state != undefined) {
                    this.client_state = data.client_state;
                }
                if ("consensus_state" in data && data.consensus_state != undefined) {
                    this.consensus_state = data.consensus_state;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_state() {
            return pb_1.Message.getWrapperField(this, Any, 1) as Any;
        }
        set client_state(value: Any) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get consensus_state() {
            return pb_1.Message.getWrapperField(this, Any, 2) as Any;
        }
        set consensus_state(value: Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            client_state?: ReturnType<typeof Any.prototype.toObject>;
            consensus_state?: ReturnType<typeof Any.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgCreateClient({});
            if (data.client_state != null) {
                message.client_state = Any.fromObject(data.client_state);
            }
            if (data.consensus_state != null) {
                message.consensus_state = Any.fromObject(data.consensus_state);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_state?: ReturnType<typeof Any.prototype.toObject>;
                consensus_state?: ReturnType<typeof Any.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.client_state != null) {
                data.client_state = this.client_state.toObject();
            }
            if (this.consensus_state != null) {
                data.consensus_state = this.consensus_state.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.client_state !== undefined)
                writer.writeMessage(1, this.client_state, () => this.client_state.serialize(writer));
            if (this.consensus_state !== undefined)
                writer.writeMessage(2, this.consensus_state, () => this.consensus_state.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(3, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgCreateClient {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgCreateClient();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.client_state, () => message.client_state = Any.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.consensus_state, () => message.consensus_state = Any.deserialize(reader));
                        break;
                    case 3:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgCreateClient {
            return MsgCreateClient.deserialize(bytes);
        }
    }
    export class MsgUpdateClient extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            header?: Any;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get header() {
            return pb_1.Message.getWrapperField(this, Any, 2) as Any;
        }
        set header(value: Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            client_id?: string;
            header?: ReturnType<typeof Any.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgUpdateClient({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.header != null) {
                message.header = Any.fromObject(data.header);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                header?: ReturnType<typeof Any.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (this.header !== undefined)
                writer.writeMessage(2, this.header, () => this.header.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(3, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpdateClient {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpdateClient();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.header, () => message.header = Any.deserialize(reader));
                        break;
                    case 3:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpdateClient {
            return MsgUpdateClient.deserialize(bytes);
        }
    }
    export class MsgUpgradeClient extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            client_state?: Any;
            consensus_state?: Any;
            proof_upgrade_client?: Uint8Array;
            proof_upgrade_consensus_state?: Uint8Array;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("client_state" in data && data.client_state != undefined) {
                    this.client_state = data.client_state;
                }
                if ("consensus_state" in data && data.consensus_state != undefined) {
                    this.consensus_state = data.consensus_state;
                }
                if ("proof_upgrade_client" in data && data.proof_upgrade_client != undefined) {
                    this.proof_upgrade_client = data.proof_upgrade_client;
                }
                if ("proof_upgrade_consensus_state" in data && data.proof_upgrade_consensus_state != undefined) {
                    this.proof_upgrade_consensus_state = data.proof_upgrade_consensus_state;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get client_state() {
            return pb_1.Message.getWrapperField(this, Any, 2) as Any;
        }
        set client_state(value: Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get consensus_state() {
            return pb_1.Message.getWrapperField(this, Any, 3) as Any;
        }
        set consensus_state(value: Any) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get proof_upgrade_client() {
            return pb_1.Message.getField(this, 4) as Uint8Array;
        }
        set proof_upgrade_client(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get proof_upgrade_consensus_state() {
            return pb_1.Message.getField(this, 5) as Uint8Array;
        }
        set proof_upgrade_consensus_state(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            client_id?: string;
            client_state?: ReturnType<typeof Any.prototype.toObject>;
            consensus_state?: ReturnType<typeof Any.prototype.toObject>;
            proof_upgrade_client?: Uint8Array;
            proof_upgrade_consensus_state?: Uint8Array;
            signer?: string;
        }) {
            const message = new MsgUpgradeClient({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.client_state != null) {
                message.client_state = Any.fromObject(data.client_state);
            }
            if (data.consensus_state != null) {
                message.consensus_state = Any.fromObject(data.consensus_state);
            }
            if (data.proof_upgrade_client != null) {
                message.proof_upgrade_client = data.proof_upgrade_client;
            }
            if (data.proof_upgrade_consensus_state != null) {
                message.proof_upgrade_consensus_state = data.proof_upgrade_consensus_state;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                client_state?: ReturnType<typeof Any.prototype.toObject>;
                consensus_state?: ReturnType<typeof Any.prototype.toObject>;
                proof_upgrade_client?: Uint8Array;
                proof_upgrade_consensus_state?: Uint8Array;
                signer?: string;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.client_state != null) {
                data.client_state = this.client_state.toObject();
            }
            if (this.consensus_state != null) {
                data.consensus_state = this.consensus_state.toObject();
            }
            if (this.proof_upgrade_client != null) {
                data.proof_upgrade_client = this.proof_upgrade_client;
            }
            if (this.proof_upgrade_consensus_state != null) {
                data.proof_upgrade_consensus_state = this.proof_upgrade_consensus_state;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (this.client_state !== undefined)
                writer.writeMessage(2, this.client_state, () => this.client_state.serialize(writer));
            if (this.consensus_state !== undefined)
                writer.writeMessage(3, this.consensus_state, () => this.consensus_state.serialize(writer));
            if (this.proof_upgrade_client !== undefined)
                writer.writeBytes(4, this.proof_upgrade_client);
            if (this.proof_upgrade_consensus_state !== undefined)
                writer.writeBytes(5, this.proof_upgrade_consensus_state);
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(6, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgUpgradeClient {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgUpgradeClient();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.client_state, () => message.client_state = Any.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.consensus_state, () => message.consensus_state = Any.deserialize(reader));
                        break;
                    case 4:
                        message.proof_upgrade_client = reader.readBytes();
                        break;
                    case 5:
                        message.proof_upgrade_consensus_state = reader.readBytes();
                        break;
                    case 6:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgUpgradeClient {
            return MsgUpgradeClient.deserialize(bytes);
        }
    }
    export class MsgSubmitMisbehaviour extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            misbehaviour?: Any;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("misbehaviour" in data && data.misbehaviour != undefined) {
                    this.misbehaviour = data.misbehaviour;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get misbehaviour() {
            return pb_1.Message.getWrapperField(this, Any, 2) as Any;
        }
        set misbehaviour(value: Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            client_id?: string;
            misbehaviour?: ReturnType<typeof Any.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgSubmitMisbehaviour({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.misbehaviour != null) {
                message.misbehaviour = Any.fromObject(data.misbehaviour);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                misbehaviour?: ReturnType<typeof Any.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.misbehaviour != null) {
                data.misbehaviour = this.misbehaviour.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (this.misbehaviour !== undefined)
                writer.writeMessage(2, this.misbehaviour, () => this.misbehaviour.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(3, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgSubmitMisbehaviour {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgSubmitMisbehaviour();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.misbehaviour, () => message.misbehaviour = Any.deserialize(reader));
                        break;
                    case 3:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgSubmitMisbehaviour {
            return MsgSubmitMisbehaviour.deserialize(bytes);
        }
    }
    export class MsgConnectionOpenInit extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            counterparty?: ConnectionCounterparty;
            version?: ConnectionVersion;
            delay_period?: number;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("counterparty" in data && data.counterparty != undefined) {
                    this.counterparty = data.counterparty;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("delay_period" in data && data.delay_period != undefined) {
                    this.delay_period = data.delay_period;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get counterparty() {
            return pb_1.Message.getWrapperField(this, ConnectionCounterparty, 2) as ConnectionCounterparty;
        }
        set counterparty(value: ConnectionCounterparty) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get version() {
            return pb_1.Message.getWrapperField(this, ConnectionVersion, 3) as ConnectionVersion;
        }
        set version(value: ConnectionVersion) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get delay_period() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set delay_period(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            client_id?: string;
            counterparty?: ReturnType<typeof ConnectionCounterparty.prototype.toObject>;
            version?: ReturnType<typeof ConnectionVersion.prototype.toObject>;
            delay_period?: number;
            signer?: string;
        }) {
            const message = new MsgConnectionOpenInit({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.counterparty != null) {
                message.counterparty = ConnectionCounterparty.fromObject(data.counterparty);
            }
            if (data.version != null) {
                message.version = ConnectionVersion.fromObject(data.version);
            }
            if (data.delay_period != null) {
                message.delay_period = data.delay_period;
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                counterparty?: ReturnType<typeof ConnectionCounterparty.prototype.toObject>;
                version?: ReturnType<typeof ConnectionVersion.prototype.toObject>;
                delay_period?: number;
                signer?: string;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.counterparty != null) {
                data.counterparty = this.counterparty.toObject();
            }
            if (this.version != null) {
                data.version = this.version.toObject();
            }
            if (this.delay_period != null) {
                data.delay_period = this.delay_period;
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (this.counterparty !== undefined)
                writer.writeMessage(2, this.counterparty, () => this.counterparty.serialize(writer));
            if (this.version !== undefined)
                writer.writeMessage(3, this.version, () => this.version.serialize(writer));
            if (this.delay_period !== undefined)
                writer.writeUint64(4, this.delay_period);
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(5, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConnectionOpenInit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConnectionOpenInit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.counterparty, () => message.counterparty = ConnectionCounterparty.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.version, () => message.version = ConnectionVersion.deserialize(reader));
                        break;
                    case 4:
                        message.delay_period = reader.readUint64();
                        break;
                    case 5:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConnectionOpenInit {
            return MsgConnectionOpenInit.deserialize(bytes);
        }
    }
    export class MsgConnectionOpenTry extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            previous_connection_id?: string;
            client_state?: Any;
            counterparty?: ConnectionCounterparty;
            delay_period?: number;
            counterparty_versions?: ConnectionVersion[];
            proof_height?: Height;
            proof_init?: Uint8Array;
            proof_client?: Uint8Array;
            proof_consensus?: Uint8Array;
            consensus_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("previous_connection_id" in data && data.previous_connection_id != undefined) {
                    this.previous_connection_id = data.previous_connection_id;
                }
                if ("client_state" in data && data.client_state != undefined) {
                    this.client_state = data.client_state;
                }
                if ("counterparty" in data && data.counterparty != undefined) {
                    this.counterparty = data.counterparty;
                }
                if ("delay_period" in data && data.delay_period != undefined) {
                    this.delay_period = data.delay_period;
                }
                if ("counterparty_versions" in data && data.counterparty_versions != undefined) {
                    this.counterparty_versions = data.counterparty_versions;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("proof_init" in data && data.proof_init != undefined) {
                    this.proof_init = data.proof_init;
                }
                if ("proof_client" in data && data.proof_client != undefined) {
                    this.proof_client = data.proof_client;
                }
                if ("proof_consensus" in data && data.proof_consensus != undefined) {
                    this.proof_consensus = data.proof_consensus;
                }
                if ("consensus_height" in data && data.consensus_height != undefined) {
                    this.consensus_height = data.consensus_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get previous_connection_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set previous_connection_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get client_state() {
            return pb_1.Message.getWrapperField(this, Any, 3) as Any;
        }
        set client_state(value: Any) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get counterparty() {
            return pb_1.Message.getWrapperField(this, ConnectionCounterparty, 4) as ConnectionCounterparty;
        }
        set counterparty(value: ConnectionCounterparty) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get delay_period() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set delay_period(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get counterparty_versions() {
            return pb_1.Message.getRepeatedWrapperField(this, ConnectionVersion, 6) as ConnectionVersion[];
        }
        set counterparty_versions(value: ConnectionVersion[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 7) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get proof_init() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set proof_init(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get proof_client() {
            return pb_1.Message.getField(this, 9) as Uint8Array;
        }
        set proof_client(value: Uint8Array) {
            pb_1.Message.setField(this, 9, value);
        }
        get proof_consensus() {
            return pb_1.Message.getField(this, 10) as Uint8Array;
        }
        set proof_consensus(value: Uint8Array) {
            pb_1.Message.setField(this, 10, value);
        }
        get consensus_height() {
            return pb_1.Message.getWrapperField(this, Height, 11) as Height;
        }
        set consensus_height(value: Height) {
            pb_1.Message.setWrapperField(this, 11, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 12) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 12, value);
        }
        static fromObject(data: {
            client_id?: string;
            previous_connection_id?: string;
            client_state?: ReturnType<typeof Any.prototype.toObject>;
            counterparty?: ReturnType<typeof ConnectionCounterparty.prototype.toObject>;
            delay_period?: number;
            counterparty_versions?: ReturnType<typeof ConnectionVersion.prototype.toObject>[];
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            proof_init?: Uint8Array;
            proof_client?: Uint8Array;
            proof_consensus?: Uint8Array;
            consensus_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgConnectionOpenTry({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.previous_connection_id != null) {
                message.previous_connection_id = data.previous_connection_id;
            }
            if (data.client_state != null) {
                message.client_state = Any.fromObject(data.client_state);
            }
            if (data.counterparty != null) {
                message.counterparty = ConnectionCounterparty.fromObject(data.counterparty);
            }
            if (data.delay_period != null) {
                message.delay_period = data.delay_period;
            }
            if (data.counterparty_versions != null) {
                message.counterparty_versions = data.counterparty_versions.map(item => ConnectionVersion.fromObject(item));
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.proof_init != null) {
                message.proof_init = data.proof_init;
            }
            if (data.proof_client != null) {
                message.proof_client = data.proof_client;
            }
            if (data.proof_consensus != null) {
                message.proof_consensus = data.proof_consensus;
            }
            if (data.consensus_height != null) {
                message.consensus_height = Height.fromObject(data.consensus_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                previous_connection_id?: string;
                client_state?: ReturnType<typeof Any.prototype.toObject>;
                counterparty?: ReturnType<typeof ConnectionCounterparty.prototype.toObject>;
                delay_period?: number;
                counterparty_versions?: ReturnType<typeof ConnectionVersion.prototype.toObject>[];
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                proof_init?: Uint8Array;
                proof_client?: Uint8Array;
                proof_consensus?: Uint8Array;
                consensus_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.previous_connection_id != null) {
                data.previous_connection_id = this.previous_connection_id;
            }
            if (this.client_state != null) {
                data.client_state = this.client_state.toObject();
            }
            if (this.counterparty != null) {
                data.counterparty = this.counterparty.toObject();
            }
            if (this.delay_period != null) {
                data.delay_period = this.delay_period;
            }
            if (this.counterparty_versions != null) {
                data.counterparty_versions = this.counterparty_versions.map((item: ConnectionVersion) => item.toObject());
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.proof_init != null) {
                data.proof_init = this.proof_init;
            }
            if (this.proof_client != null) {
                data.proof_client = this.proof_client;
            }
            if (this.proof_consensus != null) {
                data.proof_consensus = this.proof_consensus;
            }
            if (this.consensus_height != null) {
                data.consensus_height = this.consensus_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (typeof this.previous_connection_id === "string" && this.previous_connection_id.length)
                writer.writeString(2, this.previous_connection_id);
            if (this.client_state !== undefined)
                writer.writeMessage(3, this.client_state, () => this.client_state.serialize(writer));
            if (this.counterparty !== undefined)
                writer.writeMessage(4, this.counterparty, () => this.counterparty.serialize(writer));
            if (this.delay_period !== undefined)
                writer.writeUint64(5, this.delay_period);
            if (this.counterparty_versions !== undefined)
                writer.writeRepeatedMessage(6, this.counterparty_versions, (item: ConnectionVersion) => item.serialize(writer));
            if (this.proof_height !== undefined)
                writer.writeMessage(7, this.proof_height, () => this.proof_height.serialize(writer));
            if (this.proof_init !== undefined)
                writer.writeBytes(8, this.proof_init);
            if (this.proof_client !== undefined)
                writer.writeBytes(9, this.proof_client);
            if (this.proof_consensus !== undefined)
                writer.writeBytes(10, this.proof_consensus);
            if (this.consensus_height !== undefined)
                writer.writeMessage(11, this.consensus_height, () => this.consensus_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(12, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConnectionOpenTry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConnectionOpenTry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        message.previous_connection_id = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.client_state, () => message.client_state = Any.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.counterparty, () => message.counterparty = ConnectionCounterparty.deserialize(reader));
                        break;
                    case 5:
                        message.delay_period = reader.readUint64();
                        break;
                    case 6:
                        reader.readMessage(message.counterparty_versions, () => pb_1.Message.addToRepeatedWrapperField(message, 6, ConnectionVersion.deserialize(reader), ConnectionVersion));
                        break;
                    case 7:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 8:
                        message.proof_init = reader.readBytes();
                        break;
                    case 9:
                        message.proof_client = reader.readBytes();
                        break;
                    case 10:
                        message.proof_consensus = reader.readBytes();
                        break;
                    case 11:
                        reader.readMessage(message.consensus_height, () => message.consensus_height = Height.deserialize(reader));
                        break;
                    case 12:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConnectionOpenTry {
            return MsgConnectionOpenTry.deserialize(bytes);
        }
    }
    export class MsgConnectionOpenAck extends pb_1.Message {
        constructor(data?: any[] | {
            connection_id?: string;
            counterparty_connection_id?: string;
            version?: ConnectionVersion;
            client_state?: Any;
            proof_height?: Height;
            proof_try?: Uint8Array;
            proof_client?: Uint8Array;
            proof_consensus?: Uint8Array;
            consensus_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("connection_id" in data && data.connection_id != undefined) {
                    this.connection_id = data.connection_id;
                }
                if ("counterparty_connection_id" in data && data.counterparty_connection_id != undefined) {
                    this.counterparty_connection_id = data.counterparty_connection_id;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
                if ("client_state" in data && data.client_state != undefined) {
                    this.client_state = data.client_state;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("proof_try" in data && data.proof_try != undefined) {
                    this.proof_try = data.proof_try;
                }
                if ("proof_client" in data && data.proof_client != undefined) {
                    this.proof_client = data.proof_client;
                }
                if ("proof_consensus" in data && data.proof_consensus != undefined) {
                    this.proof_consensus = data.proof_consensus;
                }
                if ("consensus_height" in data && data.consensus_height != undefined) {
                    this.consensus_height = data.consensus_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get connection_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set connection_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get counterparty_connection_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set counterparty_connection_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get version() {
            return pb_1.Message.getWrapperField(this, ConnectionVersion, 3) as ConnectionVersion;
        }
        set version(value: ConnectionVersion) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get client_state() {
            return pb_1.Message.getWrapperField(this, Any, 4) as Any;
        }
        set client_state(value: Any) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 5) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get proof_try() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set proof_try(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get proof_client() {
            return pb_1.Message.getField(this, 7) as Uint8Array;
        }
        set proof_client(value: Uint8Array) {
            pb_1.Message.setField(this, 7, value);
        }
        get proof_consensus() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set proof_consensus(value: Uint8Array) {
            pb_1.Message.setField(this, 8, value);
        }
        get consensus_height() {
            return pb_1.Message.getWrapperField(this, Height, 9) as Height;
        }
        set consensus_height(value: Height) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 10) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 10, value);
        }
        static fromObject(data: {
            connection_id?: string;
            counterparty_connection_id?: string;
            version?: ReturnType<typeof ConnectionVersion.prototype.toObject>;
            client_state?: ReturnType<typeof Any.prototype.toObject>;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            proof_try?: Uint8Array;
            proof_client?: Uint8Array;
            proof_consensus?: Uint8Array;
            consensus_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgConnectionOpenAck({});
            if (data.connection_id != null) {
                message.connection_id = data.connection_id;
            }
            if (data.counterparty_connection_id != null) {
                message.counterparty_connection_id = data.counterparty_connection_id;
            }
            if (data.version != null) {
                message.version = ConnectionVersion.fromObject(data.version);
            }
            if (data.client_state != null) {
                message.client_state = Any.fromObject(data.client_state);
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.proof_try != null) {
                message.proof_try = data.proof_try;
            }
            if (data.proof_client != null) {
                message.proof_client = data.proof_client;
            }
            if (data.proof_consensus != null) {
                message.proof_consensus = data.proof_consensus;
            }
            if (data.consensus_height != null) {
                message.consensus_height = Height.fromObject(data.consensus_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                connection_id?: string;
                counterparty_connection_id?: string;
                version?: ReturnType<typeof ConnectionVersion.prototype.toObject>;
                client_state?: ReturnType<typeof Any.prototype.toObject>;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                proof_try?: Uint8Array;
                proof_client?: Uint8Array;
                proof_consensus?: Uint8Array;
                consensus_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.connection_id != null) {
                data.connection_id = this.connection_id;
            }
            if (this.counterparty_connection_id != null) {
                data.counterparty_connection_id = this.counterparty_connection_id;
            }
            if (this.version != null) {
                data.version = this.version.toObject();
            }
            if (this.client_state != null) {
                data.client_state = this.client_state.toObject();
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.proof_try != null) {
                data.proof_try = this.proof_try;
            }
            if (this.proof_client != null) {
                data.proof_client = this.proof_client;
            }
            if (this.proof_consensus != null) {
                data.proof_consensus = this.proof_consensus;
            }
            if (this.consensus_height != null) {
                data.consensus_height = this.consensus_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.connection_id === "string" && this.connection_id.length)
                writer.writeString(1, this.connection_id);
            if (typeof this.counterparty_connection_id === "string" && this.counterparty_connection_id.length)
                writer.writeString(2, this.counterparty_connection_id);
            if (this.version !== undefined)
                writer.writeMessage(3, this.version, () => this.version.serialize(writer));
            if (this.client_state !== undefined)
                writer.writeMessage(4, this.client_state, () => this.client_state.serialize(writer));
            if (this.proof_height !== undefined)
                writer.writeMessage(5, this.proof_height, () => this.proof_height.serialize(writer));
            if (this.proof_try !== undefined)
                writer.writeBytes(6, this.proof_try);
            if (this.proof_client !== undefined)
                writer.writeBytes(7, this.proof_client);
            if (this.proof_consensus !== undefined)
                writer.writeBytes(8, this.proof_consensus);
            if (this.consensus_height !== undefined)
                writer.writeMessage(9, this.consensus_height, () => this.consensus_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(10, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConnectionOpenAck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConnectionOpenAck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.connection_id = reader.readString();
                        break;
                    case 2:
                        message.counterparty_connection_id = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.version, () => message.version = ConnectionVersion.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.client_state, () => message.client_state = Any.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 6:
                        message.proof_try = reader.readBytes();
                        break;
                    case 7:
                        message.proof_client = reader.readBytes();
                        break;
                    case 8:
                        message.proof_consensus = reader.readBytes();
                        break;
                    case 9:
                        reader.readMessage(message.consensus_height, () => message.consensus_height = Height.deserialize(reader));
                        break;
                    case 10:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConnectionOpenAck {
            return MsgConnectionOpenAck.deserialize(bytes);
        }
    }
    export class MsgConnectionOpenConfirm extends pb_1.Message {
        constructor(data?: any[] | {
            connection_id?: string;
            proof_ack?: Uint8Array;
            proof_height?: Height;
            signer?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("connection_id" in data && data.connection_id != undefined) {
                    this.connection_id = data.connection_id;
                }
                if ("proof_ack" in data && data.proof_ack != undefined) {
                    this.proof_ack = data.proof_ack;
                }
                if ("proof_height" in data && data.proof_height != undefined) {
                    this.proof_height = data.proof_height;
                }
                if ("signer" in data && data.signer != undefined) {
                    this.signer = data.signer;
                }
            }
        }
        get connection_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set connection_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get proof_ack() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set proof_ack(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get proof_height() {
            return pb_1.Message.getWrapperField(this, Height, 3) as Height;
        }
        set proof_height(value: Height) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get signer() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set signer(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            connection_id?: string;
            proof_ack?: Uint8Array;
            proof_height?: ReturnType<typeof Height.prototype.toObject>;
            signer?: string;
        }) {
            const message = new MsgConnectionOpenConfirm({});
            if (data.connection_id != null) {
                message.connection_id = data.connection_id;
            }
            if (data.proof_ack != null) {
                message.proof_ack = data.proof_ack;
            }
            if (data.proof_height != null) {
                message.proof_height = Height.fromObject(data.proof_height);
            }
            if (data.signer != null) {
                message.signer = data.signer;
            }
            return message;
        }
        toObject() {
            const data: {
                connection_id?: string;
                proof_ack?: Uint8Array;
                proof_height?: ReturnType<typeof Height.prototype.toObject>;
                signer?: string;
            } = {};
            if (this.connection_id != null) {
                data.connection_id = this.connection_id;
            }
            if (this.proof_ack != null) {
                data.proof_ack = this.proof_ack;
            }
            if (this.proof_height != null) {
                data.proof_height = this.proof_height.toObject();
            }
            if (this.signer != null) {
                data.signer = this.signer;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.connection_id === "string" && this.connection_id.length)
                writer.writeString(1, this.connection_id);
            if (this.proof_ack !== undefined)
                writer.writeBytes(2, this.proof_ack);
            if (this.proof_height !== undefined)
                writer.writeMessage(3, this.proof_height, () => this.proof_height.serialize(writer));
            if (typeof this.signer === "string" && this.signer.length)
                writer.writeString(4, this.signer);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MsgConnectionOpenConfirm {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MsgConnectionOpenConfirm();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.connection_id = reader.readString();
                        break;
                    case 2:
                        message.proof_ack = reader.readBytes();
                        break;
                    case 3:
                        reader.readMessage(message.proof_height, () => message.proof_height = Height.deserialize(reader));
                        break;
                    case 4:
                        message.signer = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MsgConnectionOpenConfirm {
            return MsgConnectionOpenConfirm.deserialize(bytes);
        }
    }
    export class Channel extends pb_1.Message {
        constructor(data?: any[] | {
            state?: State;
            ordering?: Order;
            counterparty?: ChannelCounterparty;
            connection_hops?: string[];
            version?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("ordering" in data && data.ordering != undefined) {
                    this.ordering = data.ordering;
                }
                if ("counterparty" in data && data.counterparty != undefined) {
                    this.counterparty = data.counterparty;
                }
                if ("connection_hops" in data && data.connection_hops != undefined) {
                    this.connection_hops = data.connection_hops;
                }
                if ("version" in data && data.version != undefined) {
                    this.version = data.version;
                }
            }
        }
        get state() {
            return pb_1.Message.getField(this, 1) as State;
        }
        set state(value: State) {
            pb_1.Message.setField(this, 1, value);
        }
        get ordering() {
            return pb_1.Message.getField(this, 2) as Order;
        }
        set ordering(value: Order) {
            pb_1.Message.setField(this, 2, value);
        }
        get counterparty() {
            return pb_1.Message.getWrapperField(this, ChannelCounterparty, 3) as ChannelCounterparty;
        }
        set counterparty(value: ChannelCounterparty) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get connection_hops() {
            return pb_1.Message.getField(this, 4) as string[];
        }
        set connection_hops(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get version() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set version(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            state?: State;
            ordering?: Order;
            counterparty?: ReturnType<typeof ChannelCounterparty.prototype.toObject>;
            connection_hops?: string[];
            version?: string;
        }) {
            const message = new Channel({});
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.ordering != null) {
                message.ordering = data.ordering;
            }
            if (data.counterparty != null) {
                message.counterparty = ChannelCounterparty.fromObject(data.counterparty);
            }
            if (data.connection_hops != null) {
                message.connection_hops = data.connection_hops;
            }
            if (data.version != null) {
                message.version = data.version;
            }
            return message;
        }
        toObject() {
            const data: {
                state?: State;
                ordering?: Order;
                counterparty?: ReturnType<typeof ChannelCounterparty.prototype.toObject>;
                connection_hops?: string[];
                version?: string;
            } = {};
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.ordering != null) {
                data.ordering = this.ordering;
            }
            if (this.counterparty != null) {
                data.counterparty = this.counterparty.toObject();
            }
            if (this.connection_hops != null) {
                data.connection_hops = this.connection_hops;
            }
            if (this.version != null) {
                data.version = this.version;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.state !== undefined)
                writer.writeEnum(1, this.state);
            if (this.ordering !== undefined)
                writer.writeEnum(2, this.ordering);
            if (this.counterparty !== undefined)
                writer.writeMessage(3, this.counterparty, () => this.counterparty.serialize(writer));
            if (this.connection_hops !== undefined)
                writer.writeRepeatedString(4, this.connection_hops);
            if (typeof this.version === "string" && this.version.length)
                writer.writeString(5, this.version);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Channel {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Channel();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.state = reader.readEnum();
                        break;
                    case 2:
                        message.ordering = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.counterparty, () => message.counterparty = ChannelCounterparty.deserialize(reader));
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 5:
                        message.version = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Channel {
            return Channel.deserialize(bytes);
        }
    }
    export class ChannelCounterparty extends pb_1.Message {
        constructor(data?: any[] | {
            port_id?: string;
            channel_id?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("port_id" in data && data.port_id != undefined) {
                    this.port_id = data.port_id;
                }
                if ("channel_id" in data && data.channel_id != undefined) {
                    this.channel_id = data.channel_id;
                }
            }
        }
        get port_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set port_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get channel_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set channel_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            port_id?: string;
            channel_id?: string;
        }) {
            const message = new ChannelCounterparty({});
            if (data.port_id != null) {
                message.port_id = data.port_id;
            }
            if (data.channel_id != null) {
                message.channel_id = data.channel_id;
            }
            return message;
        }
        toObject() {
            const data: {
                port_id?: string;
                channel_id?: string;
            } = {};
            if (this.port_id != null) {
                data.port_id = this.port_id;
            }
            if (this.channel_id != null) {
                data.channel_id = this.channel_id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.port_id === "string" && this.port_id.length)
                writer.writeString(1, this.port_id);
            if (typeof this.channel_id === "string" && this.channel_id.length)
                writer.writeString(2, this.channel_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ChannelCounterparty {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ChannelCounterparty();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.port_id = reader.readString();
                        break;
                    case 2:
                        message.channel_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ChannelCounterparty {
            return ChannelCounterparty.deserialize(bytes);
        }
    }
    export class CommissionRates extends pb_1.Message {
        constructor(data?: any[] | {
            rate?: string;
            max_rate?: string;
            max_change_rate?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rate" in data && data.rate != undefined) {
                    this.rate = data.rate;
                }
                if ("max_rate" in data && data.max_rate != undefined) {
                    this.max_rate = data.max_rate;
                }
                if ("max_change_rate" in data && data.max_change_rate != undefined) {
                    this.max_change_rate = data.max_change_rate;
                }
            }
        }
        get rate() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set rate(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get max_rate() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set max_rate(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get max_change_rate() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set max_change_rate(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            rate?: string;
            max_rate?: string;
            max_change_rate?: string;
        }) {
            const message = new CommissionRates({});
            if (data.rate != null) {
                message.rate = data.rate;
            }
            if (data.max_rate != null) {
                message.max_rate = data.max_rate;
            }
            if (data.max_change_rate != null) {
                message.max_change_rate = data.max_change_rate;
            }
            return message;
        }
        toObject() {
            const data: {
                rate?: string;
                max_rate?: string;
                max_change_rate?: string;
            } = {};
            if (this.rate != null) {
                data.rate = this.rate;
            }
            if (this.max_rate != null) {
                data.max_rate = this.max_rate;
            }
            if (this.max_change_rate != null) {
                data.max_change_rate = this.max_change_rate;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.rate === "string" && this.rate.length)
                writer.writeString(1, this.rate);
            if (typeof this.max_rate === "string" && this.max_rate.length)
                writer.writeString(2, this.max_rate);
            if (typeof this.max_change_rate === "string" && this.max_change_rate.length)
                writer.writeString(3, this.max_change_rate);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CommissionRates {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CommissionRates();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.rate = reader.readString();
                        break;
                    case 2:
                        message.max_rate = reader.readString();
                        break;
                    case 3:
                        message.max_change_rate = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CommissionRates {
            return CommissionRates.deserialize(bytes);
        }
    }
    export class ConnectionCounterparty extends pb_1.Message {
        constructor(data?: any[] | {
            client_id?: string;
            connection_id?: string;
            prefix?: MerklePrefix;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("client_id" in data && data.client_id != undefined) {
                    this.client_id = data.client_id;
                }
                if ("connection_id" in data && data.connection_id != undefined) {
                    this.connection_id = data.connection_id;
                }
                if ("prefix" in data && data.prefix != undefined) {
                    this.prefix = data.prefix;
                }
            }
        }
        get client_id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set client_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get connection_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set connection_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get prefix() {
            return pb_1.Message.getWrapperField(this, MerklePrefix, 3) as MerklePrefix;
        }
        set prefix(value: MerklePrefix) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        static fromObject(data: {
            client_id?: string;
            connection_id?: string;
            prefix?: ReturnType<typeof MerklePrefix.prototype.toObject>;
        }) {
            const message = new ConnectionCounterparty({});
            if (data.client_id != null) {
                message.client_id = data.client_id;
            }
            if (data.connection_id != null) {
                message.connection_id = data.connection_id;
            }
            if (data.prefix != null) {
                message.prefix = MerklePrefix.fromObject(data.prefix);
            }
            return message;
        }
        toObject() {
            const data: {
                client_id?: string;
                connection_id?: string;
                prefix?: ReturnType<typeof MerklePrefix.prototype.toObject>;
            } = {};
            if (this.client_id != null) {
                data.client_id = this.client_id;
            }
            if (this.connection_id != null) {
                data.connection_id = this.connection_id;
            }
            if (this.prefix != null) {
                data.prefix = this.prefix.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.client_id === "string" && this.client_id.length)
                writer.writeString(1, this.client_id);
            if (typeof this.connection_id === "string" && this.connection_id.length)
                writer.writeString(2, this.connection_id);
            if (this.prefix !== undefined)
                writer.writeMessage(3, this.prefix, () => this.prefix.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionCounterparty {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionCounterparty();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.client_id = reader.readString();
                        break;
                    case 2:
                        message.connection_id = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.prefix, () => message.prefix = MerklePrefix.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConnectionCounterparty {
            return ConnectionCounterparty.deserialize(bytes);
        }
    }
    export class ConnectionVersion extends pb_1.Message {
        constructor(data?: any[] | {
            identifier?: string;
            features?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("identifier" in data && data.identifier != undefined) {
                    this.identifier = data.identifier;
                }
                if ("features" in data && data.features != undefined) {
                    this.features = data.features;
                }
            }
        }
        get identifier() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set identifier(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get features() {
            return pb_1.Message.getField(this, 2) as string[];
        }
        set features(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            identifier?: string;
            features?: string[];
        }) {
            const message = new ConnectionVersion({});
            if (data.identifier != null) {
                message.identifier = data.identifier;
            }
            if (data.features != null) {
                message.features = data.features;
            }
            return message;
        }
        toObject() {
            const data: {
                identifier?: string;
                features?: string[];
            } = {};
            if (this.identifier != null) {
                data.identifier = this.identifier;
            }
            if (this.features != null) {
                data.features = this.features;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.identifier === "string" && this.identifier.length)
                writer.writeString(1, this.identifier);
            if (this.features !== undefined)
                writer.writeRepeatedString(2, this.features);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionVersion {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionVersion();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.identifier = reader.readString();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConnectionVersion {
            return ConnectionVersion.deserialize(bytes);
        }
    }
    export class Description extends pb_1.Message {
        constructor(data?: any[] | {
            moniker?: string;
            identity?: string;
            website?: string;
            security_contact?: string;
            details?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("moniker" in data && data.moniker != undefined) {
                    this.moniker = data.moniker;
                }
                if ("identity" in data && data.identity != undefined) {
                    this.identity = data.identity;
                }
                if ("website" in data && data.website != undefined) {
                    this.website = data.website;
                }
                if ("security_contact" in data && data.security_contact != undefined) {
                    this.security_contact = data.security_contact;
                }
                if ("details" in data && data.details != undefined) {
                    this.details = data.details;
                }
            }
        }
        get moniker() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set moniker(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get identity() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set identity(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get website() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set website(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get security_contact() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set security_contact(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get details() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set details(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            moniker?: string;
            identity?: string;
            website?: string;
            security_contact?: string;
            details?: string;
        }) {
            const message = new Description({});
            if (data.moniker != null) {
                message.moniker = data.moniker;
            }
            if (data.identity != null) {
                message.identity = data.identity;
            }
            if (data.website != null) {
                message.website = data.website;
            }
            if (data.security_contact != null) {
                message.security_contact = data.security_contact;
            }
            if (data.details != null) {
                message.details = data.details;
            }
            return message;
        }
        toObject() {
            const data: {
                moniker?: string;
                identity?: string;
                website?: string;
                security_contact?: string;
                details?: string;
            } = {};
            if (this.moniker != null) {
                data.moniker = this.moniker;
            }
            if (this.identity != null) {
                data.identity = this.identity;
            }
            if (this.website != null) {
                data.website = this.website;
            }
            if (this.security_contact != null) {
                data.security_contact = this.security_contact;
            }
            if (this.details != null) {
                data.details = this.details;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.moniker === "string" && this.moniker.length)
                writer.writeString(1, this.moniker);
            if (typeof this.identity === "string" && this.identity.length)
                writer.writeString(2, this.identity);
            if (typeof this.website === "string" && this.website.length)
                writer.writeString(3, this.website);
            if (typeof this.security_contact === "string" && this.security_contact.length)
                writer.writeString(4, this.security_contact);
            if (typeof this.details === "string" && this.details.length)
                writer.writeString(5, this.details);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Description {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Description();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.moniker = reader.readString();
                        break;
                    case 2:
                        message.identity = reader.readString();
                        break;
                    case 3:
                        message.website = reader.readString();
                        break;
                    case 4:
                        message.security_contact = reader.readString();
                        break;
                    case 5:
                        message.details = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Description {
            return Description.deserialize(bytes);
        }
    }
    export class Height extends pb_1.Message {
        constructor(data?: any[] | {
            revision_number?: number;
            revision_height?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("revision_number" in data && data.revision_number != undefined) {
                    this.revision_number = data.revision_number;
                }
                if ("revision_height" in data && data.revision_height != undefined) {
                    this.revision_height = data.revision_height;
                }
            }
        }
        get revision_number() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set revision_number(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get revision_height() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set revision_height(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            revision_number?: number;
            revision_height?: number;
        }) {
            const message = new Height({});
            if (data.revision_number != null) {
                message.revision_number = data.revision_number;
            }
            if (data.revision_height != null) {
                message.revision_height = data.revision_height;
            }
            return message;
        }
        toObject() {
            const data: {
                revision_number?: number;
                revision_height?: number;
            } = {};
            if (this.revision_number != null) {
                data.revision_number = this.revision_number;
            }
            if (this.revision_height != null) {
                data.revision_height = this.revision_height;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.revision_number !== undefined)
                writer.writeUint64(1, this.revision_number);
            if (this.revision_height !== undefined)
                writer.writeUint64(2, this.revision_height);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Height {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Height();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.revision_number = reader.readUint64();
                        break;
                    case 2:
                        message.revision_height = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Height {
            return Height.deserialize(bytes);
        }
    }
    export class Input extends pb_1.Message {
        constructor(data?: any[] | {
            address?: string;
            coins?: Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("coins" in data && data.coins != undefined) {
                    this.coins = data.coins;
                }
            }
        }
        get address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get coins() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 2) as Coin[];
        }
        set coins(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            coins?: ReturnType<typeof Coin.prototype.toObject>[];
        }) {
            const message = new Input({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.coins != null) {
                message.coins = data.coins.map(item => Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                coins?: ReturnType<typeof Coin.prototype.toObject>[];
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.coins != null) {
                data.coins = this.coins.map((item: Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.address === "string" && this.address.length)
                writer.writeString(1, this.address);
            if (this.coins !== undefined)
                writer.writeRepeatedMessage(2, this.coins, (item: Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Input {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Input();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.coins, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Coin.deserialize(reader), Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Input {
            return Input.deserialize(bytes);
        }
    }
    export class Output extends pb_1.Message {
        constructor(data?: any[] | {
            address?: string;
            coins?: Coin[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("address" in data && data.address != undefined) {
                    this.address = data.address;
                }
                if ("coins" in data && data.coins != undefined) {
                    this.coins = data.coins;
                }
            }
        }
        get address() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set address(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get coins() {
            return pb_1.Message.getRepeatedWrapperField(this, Coin, 2) as Coin[];
        }
        set coins(value: Coin[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            address?: string;
            coins?: ReturnType<typeof Coin.prototype.toObject>[];
        }) {
            const message = new Output({});
            if (data.address != null) {
                message.address = data.address;
            }
            if (data.coins != null) {
                message.coins = data.coins.map(item => Coin.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                address?: string;
                coins?: ReturnType<typeof Coin.prototype.toObject>[];
            } = {};
            if (this.address != null) {
                data.address = this.address;
            }
            if (this.coins != null) {
                data.coins = this.coins.map((item: Coin) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.address === "string" && this.address.length)
                writer.writeString(1, this.address);
            if (this.coins !== undefined)
                writer.writeRepeatedMessage(2, this.coins, (item: Coin) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Output {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Output();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.address = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.coins, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Coin.deserialize(reader), Coin));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Output {
            return Output.deserialize(bytes);
        }
    }
    export class MerklePrefix extends pb_1.Message {
        constructor(data?: any[] | {
            key_prefix?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("key_prefix" in data && data.key_prefix != undefined) {
                    this.key_prefix = data.key_prefix;
                }
            }
        }
        get key_prefix() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set key_prefix(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            key_prefix?: Uint8Array;
        }) {
            const message = new MerklePrefix({});
            if (data.key_prefix != null) {
                message.key_prefix = data.key_prefix;
            }
            return message;
        }
        toObject() {
            const data: {
                key_prefix?: Uint8Array;
            } = {};
            if (this.key_prefix != null) {
                data.key_prefix = this.key_prefix;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.key_prefix !== undefined)
                writer.writeBytes(1, this.key_prefix);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MerklePrefix {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MerklePrefix();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.key_prefix = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MerklePrefix {
            return MerklePrefix.deserialize(bytes);
        }
    }
    export class Packet extends pb_1.Message {
        constructor(data?: any[] | {
            sequence?: number;
            source_port?: string;
            source_channel?: string;
            destination_port?: string;
            destination_channel?: string;
            data?: Uint8Array;
            timeout_height?: Height;
            timeout_timestamp?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sequence" in data && data.sequence != undefined) {
                    this.sequence = data.sequence;
                }
                if ("source_port" in data && data.source_port != undefined) {
                    this.source_port = data.source_port;
                }
                if ("source_channel" in data && data.source_channel != undefined) {
                    this.source_channel = data.source_channel;
                }
                if ("destination_port" in data && data.destination_port != undefined) {
                    this.destination_port = data.destination_port;
                }
                if ("destination_channel" in data && data.destination_channel != undefined) {
                    this.destination_channel = data.destination_channel;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
                if ("timeout_height" in data && data.timeout_height != undefined) {
                    this.timeout_height = data.timeout_height;
                }
                if ("timeout_timestamp" in data && data.timeout_timestamp != undefined) {
                    this.timeout_timestamp = data.timeout_timestamp;
                }
            }
        }
        get sequence() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set sequence(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get source_port() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set source_port(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get source_channel() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set source_channel(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get destination_port() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set destination_port(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get destination_channel() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set destination_channel(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get data() {
            return pb_1.Message.getField(this, 6) as Uint8Array;
        }
        set data(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get timeout_height() {
            return pb_1.Message.getWrapperField(this, Height, 7) as Height;
        }
        set timeout_height(value: Height) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get timeout_timestamp() {
            return pb_1.Message.getField(this, 8) as number;
        }
        set timeout_timestamp(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        static fromObject(data: {
            sequence?: number;
            source_port?: string;
            source_channel?: string;
            destination_port?: string;
            destination_channel?: string;
            data?: Uint8Array;
            timeout_height?: ReturnType<typeof Height.prototype.toObject>;
            timeout_timestamp?: number;
        }) {
            const message = new Packet({});
            if (data.sequence != null) {
                message.sequence = data.sequence;
            }
            if (data.source_port != null) {
                message.source_port = data.source_port;
            }
            if (data.source_channel != null) {
                message.source_channel = data.source_channel;
            }
            if (data.destination_port != null) {
                message.destination_port = data.destination_port;
            }
            if (data.destination_channel != null) {
                message.destination_channel = data.destination_channel;
            }
            if (data.data != null) {
                message.data = data.data;
            }
            if (data.timeout_height != null) {
                message.timeout_height = Height.fromObject(data.timeout_height);
            }
            if (data.timeout_timestamp != null) {
                message.timeout_timestamp = data.timeout_timestamp;
            }
            return message;
        }
        toObject() {
            const data: {
                sequence?: number;
                source_port?: string;
                source_channel?: string;
                destination_port?: string;
                destination_channel?: string;
                data?: Uint8Array;
                timeout_height?: ReturnType<typeof Height.prototype.toObject>;
                timeout_timestamp?: number;
            } = {};
            if (this.sequence != null) {
                data.sequence = this.sequence;
            }
            if (this.source_port != null) {
                data.source_port = this.source_port;
            }
            if (this.source_channel != null) {
                data.source_channel = this.source_channel;
            }
            if (this.destination_port != null) {
                data.destination_port = this.destination_port;
            }
            if (this.destination_channel != null) {
                data.destination_channel = this.destination_channel;
            }
            if (this.data != null) {
                data.data = this.data;
            }
            if (this.timeout_height != null) {
                data.timeout_height = this.timeout_height.toObject();
            }
            if (this.timeout_timestamp != null) {
                data.timeout_timestamp = this.timeout_timestamp;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sequence !== undefined)
                writer.writeUint64(1, this.sequence);
            if (typeof this.source_port === "string" && this.source_port.length)
                writer.writeString(2, this.source_port);
            if (typeof this.source_channel === "string" && this.source_channel.length)
                writer.writeString(3, this.source_channel);
            if (typeof this.destination_port === "string" && this.destination_port.length)
                writer.writeString(4, this.destination_port);
            if (typeof this.destination_channel === "string" && this.destination_channel.length)
                writer.writeString(5, this.destination_channel);
            if (this.data !== undefined)
                writer.writeBytes(6, this.data);
            if (this.timeout_height !== undefined)
                writer.writeMessage(7, this.timeout_height, () => this.timeout_height.serialize(writer));
            if (this.timeout_timestamp !== undefined)
                writer.writeUint64(8, this.timeout_timestamp);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Packet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Packet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.sequence = reader.readUint64();
                        break;
                    case 2:
                        message.source_port = reader.readString();
                        break;
                    case 3:
                        message.source_channel = reader.readString();
                        break;
                    case 4:
                        message.destination_port = reader.readString();
                        break;
                    case 5:
                        message.destination_channel = reader.readString();
                        break;
                    case 6:
                        message.data = reader.readBytes();
                        break;
                    case 7:
                        reader.readMessage(message.timeout_height, () => message.timeout_height = Height.deserialize(reader));
                        break;
                    case 8:
                        message.timeout_timestamp = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Packet {
            return Packet.deserialize(bytes);
        }
    }
    export class CosmosHeader extends pb_1.Message {
        constructor(data?: any[] | {
            signed_header?: dependency_1.fig.tendermint.codec.v1.SignedHeader;
            validator_set?: dependency_1.fig.tendermint.codec.v1.ValidatorSet;
            trusted_height?: Height;
            trusted_validators?: dependency_1.fig.tendermint.codec.v1.ValidatorSet;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("signed_header" in data && data.signed_header != undefined) {
                    this.signed_header = data.signed_header;
                }
                if ("validator_set" in data && data.validator_set != undefined) {
                    this.validator_set = data.validator_set;
                }
                if ("trusted_height" in data && data.trusted_height != undefined) {
                    this.trusted_height = data.trusted_height;
                }
                if ("trusted_validators" in data && data.trusted_validators != undefined) {
                    this.trusted_validators = data.trusted_validators;
                }
            }
        }
        get signed_header() {
            return pb_1.Message.getWrapperField(this, dependency_1.fig.tendermint.codec.v1.SignedHeader, 1) as dependency_1.fig.tendermint.codec.v1.SignedHeader;
        }
        set signed_header(value: dependency_1.fig.tendermint.codec.v1.SignedHeader) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get validator_set() {
            return pb_1.Message.getWrapperField(this, dependency_1.fig.tendermint.codec.v1.ValidatorSet, 2) as dependency_1.fig.tendermint.codec.v1.ValidatorSet;
        }
        set validator_set(value: dependency_1.fig.tendermint.codec.v1.ValidatorSet) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get trusted_height() {
            return pb_1.Message.getWrapperField(this, Height, 3) as Height;
        }
        set trusted_height(value: Height) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get trusted_validators() {
            return pb_1.Message.getWrapperField(this, dependency_1.fig.tendermint.codec.v1.ValidatorSet, 4) as dependency_1.fig.tendermint.codec.v1.ValidatorSet;
        }
        set trusted_validators(value: dependency_1.fig.tendermint.codec.v1.ValidatorSet) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        static fromObject(data: {
            signed_header?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.SignedHeader.prototype.toObject>;
            validator_set?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.ValidatorSet.prototype.toObject>;
            trusted_height?: ReturnType<typeof Height.prototype.toObject>;
            trusted_validators?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.ValidatorSet.prototype.toObject>;
        }) {
            const message = new CosmosHeader({});
            if (data.signed_header != null) {
                message.signed_header = dependency_1.fig.tendermint.codec.v1.SignedHeader.fromObject(data.signed_header);
            }
            if (data.validator_set != null) {
                message.validator_set = dependency_1.fig.tendermint.codec.v1.ValidatorSet.fromObject(data.validator_set);
            }
            if (data.trusted_height != null) {
                message.trusted_height = Height.fromObject(data.trusted_height);
            }
            if (data.trusted_validators != null) {
                message.trusted_validators = dependency_1.fig.tendermint.codec.v1.ValidatorSet.fromObject(data.trusted_validators);
            }
            return message;
        }
        toObject() {
            const data: {
                signed_header?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.SignedHeader.prototype.toObject>;
                validator_set?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.ValidatorSet.prototype.toObject>;
                trusted_height?: ReturnType<typeof Height.prototype.toObject>;
                trusted_validators?: ReturnType<typeof dependency_1.fig.tendermint.codec.v1.ValidatorSet.prototype.toObject>;
            } = {};
            if (this.signed_header != null) {
                data.signed_header = this.signed_header.toObject();
            }
            if (this.validator_set != null) {
                data.validator_set = this.validator_set.toObject();
            }
            if (this.trusted_height != null) {
                data.trusted_height = this.trusted_height.toObject();
            }
            if (this.trusted_validators != null) {
                data.trusted_validators = this.trusted_validators.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.signed_header !== undefined)
                writer.writeMessage(1, this.signed_header, () => this.signed_header.serialize(writer));
            if (this.validator_set !== undefined)
                writer.writeMessage(2, this.validator_set, () => this.validator_set.serialize(writer));
            if (this.trusted_height !== undefined)
                writer.writeMessage(3, this.trusted_height, () => this.trusted_height.serialize(writer));
            if (this.trusted_validators !== undefined)
                writer.writeMessage(4, this.trusted_validators, () => this.trusted_validators.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CosmosHeader {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CosmosHeader();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.signed_header, () => message.signed_header = dependency_1.fig.tendermint.codec.v1.SignedHeader.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.validator_set, () => message.validator_set = dependency_1.fig.tendermint.codec.v1.ValidatorSet.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.trusted_height, () => message.trusted_height = Height.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.trusted_validators, () => message.trusted_validators = dependency_1.fig.tendermint.codec.v1.ValidatorSet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CosmosHeader {
            return CosmosHeader.deserialize(bytes);
        }
    }
}
